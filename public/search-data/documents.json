[
  {
    "slug": "/data-management/databases",
    "title": "Bases de Datos",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/data-management/databases/mongodb",
    "title": "Mongo DB",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/data-management/databases/postgres",
    "title": "Postgres",
    "description": "Esta",
    "content": ""
  },
  {
    "slug": "/data-management/databases/sql",
    "title": "SQL",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/data-management",
    "title": "Administración de datos",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/data-management/platforms",
    "title": "Plataformas de administración de datos",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/data-management/platforms/supabase",
    "title": "Supabase",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/deployments/docker",
    "title": "Docker",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/deployments",
    "title": "Despliegue de proyectos",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/deployments/vercel",
    "title": "Vercel",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/dev-templates/app-ai",
    "title": "Aplicaciones con Inteligencia Artificial",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/dev-templates/app-courses",
    "title": "Aplicaciones para cursos",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/dev-templates/app-documentation",
    "title": "Aplicaciones para documentación",
    "description": "Esta sección proporciona una descripción general de cómo comenzar a utilizar Documents, Kit de inicio de documentos de Next.js.",
    "content": "<CardGrid>\n  <Card subtitle=\"Rubix Documents\" title=\"Rubix Documents\" description=\"Este kit de inicio de documentos sirve como una base flexible y escalable para crear sitios web de documentación o proyectos basados ​​en contenido.\" href=\"/docs/dev-templates/app-documentation/rubix-documents\" />\n</CardGrid>\n"
  },
  {
    "slug": "/dev-templates/app-documentation/rubix-documents/components",
    "title": "Componentes para documentación",
    "description": "Este kit de inicio de documentos sirve como una base flexible y escalable para crear sitios web de documentación o proyectos basados ​​en contenido.",
    "content": "## CARDS\n\n### CHICAS\n\n<CardGrid>\n  <Card title=\"Instrucciones\" href=\"#\" icon=\"alignJustify\" variant=\"small\" description=\"test description\" />\n\n  <Card title=\"Configuración\" href=\"#\" icon=\"alignJustify\" variant=\"small\" />\n</CardGrid>\n\n```JSX\n<CardGrid>\r\n  <Card\r\n    title=\"Instrucciones\"\r\n    href=\"#\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n    description=\"test description\"\r\n  />\r\n  <Card\r\n    title=\"Configuración\"\r\n    href=\"#\"\r\n    icon=\"alignJustify\"\r\n    variant=\"small\"\r\n  />\r\n</CardGrid>\n```\n\n### MEDIANAS\n\n<CardGrid>\n  <Card subtitle=\"Instructions\" title=\"Installation\" description=\"Get started with Documents using our quick start installation guide to get your project started.\" href=\"#\" />\n\n  <Card subtitle=\"Setup\" title=\"Site Settings\" description=\"Setting up your Documents projects layout, links and search engine optimisation.\" href=\"#\" />\n</CardGrid>\n\n```JSX\n<CardGrid>\r\n  <Card\r\n    subtitle=\"Instructions\"\r\n    title=\"Installation\"\r\n    description=\"Get started with Documents using our quick start installation guide to get your project started.\"\r\n    href=\"#\"\r\n  />\r\n  <Card\r\n    subtitle=\"Setup\"\r\n    title=\"Site Settings\"\r\n    description=\"Setting up your Documents projects layout, links and search engine optimisation.\"\r\n    href=\"#\"\r\n  />\r\n</CardGrid>\r\n\n```\n\n### IMAGEN\n\n<CardGrid>\n  <Card title=\"Instructions\" href=\"#\" image=\"/images/og-image.png\" variant=\"image\" />\n\n  <Card title=\"Setup\" href=\"#\" image=\"/images/og-image.png\" variant=\"image\" />\n</CardGrid>\n\n```JSX\n<CardGrid>\r\n  <Card\r\n    title=\"Instructions\"\r\n    href=\"#\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n  <Card\r\n    title=\"Setup\"\r\n    href=\"#\"\r\n    image=\"/images/og-image.png\"\r\n    variant=\"image\"\r\n  />\r\n</CardGrid>\n```\n\n***\n\n## DIAGRAMAS\n\n### DIAGRAMA DE FLUJO\n\n```JSX\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    Start --> Task1;\r\n    Task1 --> Task2;\r\n    Task2 --> End;\r\n  \\`}\r\n/>\n```\n\n### ARBOL DE DECISIONES\n\n```JSX\n<Mermaid\r\n  chart={\\`\r\n    graph TD;\r\n    A[Start] --> B{Is it raining?};\r\n    B -->|Yes| C[Take an umbrella];\r\n    B -->|No| D[Enjoy the weather];\r\n    C --> E[Go outside];\r\n    D --> E;\r\n  \\`}\r\n/>\n```\n\n### DIAGRAMA DE ENTIDAD-REACCION\n\n```JSX\n<Mermaid\r\n  chart={\\`\r\n    erDiagram\r\n    CUSTOMER ||--o{ ORDER : places\r\n    ORDER ||--|{ LINE-ITEM : contains\r\n    PRODUCT ||--o{ LINE-ITEM : \"included in\"\r\n    CUSTOMER {\r\n        string name\r\n        string email\r\n    }\r\n    ORDER {\r\n        int orderNumber\r\n        date orderDate\r\n    }\r\n    LINE-ITEM {\r\n        int quantity\r\n        float price\r\n    }\r\n    PRODUCT {\r\n        int productId\r\n        string name\r\n        float price\r\n    }\r\n  \\`}\r\n/>\r\n\n```\n\n***\n\n## ARBOL DE ARCHIVOS\n\n<FileTree>\n  <Folder name=\"src\" label=\"Source Code\">\n    <File name=\"index.tsx\" label=\"Index File\" />\n\n    <Folder name=\"components\" label=\"Components\">\n      <File name=\"button.tsx\" label=\"Button Component\" />\n\n      <File name=\"input.tsx\" label=\"Input Component\" />\n    </Folder>\n\n    <Folder name=\"pages\" label=\"Pages\">\n      <File name=\"home.tsx\" label=\"Home Page\" />\n\n      <File name=\"about.tsx\" label=\"About Page\" />\n    </Folder>\n  </Folder>\n</FileTree>\n\n```JSX\n<FileTree>\r\n  <Folder name=\"src\" label=\"Source Code\">\r\n    <File name=\"index.tsx\" label=\"Index File\" />\r\n    <Folder name=\"components\" label=\"Components\">\r\n      <File name=\"button.tsx\" label=\"Button Component\" />\r\n      <File name=\"input.tsx\" label=\"Input Component\" />\r\n    </Folder>\r\n    <Folder name=\"pages\" label=\"Pages\">\r\n      <File name=\"home.tsx\" label=\"Home Page\" />\r\n      <File name=\"about.tsx\" label=\"About Page\" />\r\n    </Folder>\r\n  </Folder>\r\n</FileTree>\r\n\n```\n\n***\n\n## LISTAS\n\n### LISTA DE VERIFICACION\n\n* \\[x] Escribe el comunicado de prensa\n* \\[ ] Actualizar el sitio web\n* \\[ ] Contacta con los medios\n\n```JSX\n- [x] Escribe el comunicado de prensa\r\n- [ ] Actualizar el sitio web\r\n- [ ] Contacta con los medios\n```\n\n### LISTA SENCILLA\n\n* Item 1\n* Item 2\n* Item 3\n\n```JSX\n- Item 1\r\n- Item 2\r\n- Item 3\n```\n\n### LISTA DE NUMEROS\n\n1. Research\n2. Draft the content\n3. Review and edit\n4. Publish\n\n```JSX\n1. Research\r\n2. Draft the content\r\n3. Review and edit\r\n4. Publish\r\n\n```\n\n### LISTA ANIDADA\n\n* Main Category 1\n  * Sub Item 1.1\n  * Sub Item 1.2\n* Main Category 2\n  * Sub Item 2.1\n  * Sub Item 2.2\n\n```JSX\n- Main Category 1\r\n  - Sub Item 1.1\r\n  - Sub Item 1.2\r\n- Main Category 2\r\n  - Sub Item 2.1\r\n  - Sub Item 2.2\n```\n\n***\n\n## MATEMATICAS\n\n### ALGEBRA BASICA\n\n```math\nA = \\pi r^2\n```\n\n```jsx\nmath\r\nA = \\pi r^2\n```\n\n### FORMULA CUADRATICA\n\n```math\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n```\n\n```jsx\n[math]\r\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n```\n\n### TEOREMA DE PITAGORAS\n\n```math\nE = mc^2\n```\n\n```jsx\n[math]\r\nE = mc^2\n```\n\n***\n\n## NOTAS\n\n### NOTA ESTANDAR\n\n<Note title=\"Requerido\">\n  La funcionalidad de búsqueda del proyecto se basa en la automatización de Husky para crear\r\n  `search-data/documents.json` y garantizar que se realice la confirmación de Git para generar este\r\n  archivo.\n</Note>\n\n```jsx\n<Note title=\"Requerido\">\r\n  La funcionalidad de búsqueda del proyecto se basa en la automatización de Husky para crear\r\n`search-data/documents.json` y garantizar que se realice la confirmación de Git para generar este\r\narchivo.\r\n</Note>\n```\n\n### NOTA DE EXITO\n\n<Note title=\"Required\" type=\"success\">\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\n</Note>\n\n```jsx\n<Note title=\"Required\" type=\"success\">\r\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\r\n</Note>\n```\n\n### NOTA DE ADVERTENCIA\n\n<Note title=\"Required\" type=\"warning\">\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\n</Note>\n\n```jsx\n<Note title=\"Required\" type=\"warning\">\r\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\r\n</Note>\n```\n\n### NOTA DE PELIGRO\n\n<Note title=\"Required\" type=\"danger\">\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\n</Note>\n\n```jsx\n<Note title=\"Required\" type=\"danger\">\r\n  The project's search functionality relies on the Husky's automation to build\r\n  `search-data/documents.json` ensure git commit is performed to generate this\r\n  file.\r\n</Note>\n```\n\n***\n\n## PASOS\n\n<Step>\n  <StepItem title=\"Título 1\">\n    Contenido 1\n  </StepItem>\n\n  <StepItem title=\"Título 2\">\n    Contenido 2\n  </StepItem>\n\n  <StepItem title=\"Título 3\">\n    Contenido 3\n  </StepItem>\n</Step>\n\n```jsx\n<Step>\r\n  <StepItem title=\"Título 1\">\r\n   \r\n    Contenido 1\r\n\r\n  </StepItem>\r\n\r\n  <StepItem title=\"Título 2\">\r\n    \r\n    Contenido 2\r\n\r\n  </StepItem>\r\n\r\n  <StepItem title=\"Título 3\">\r\n    \r\n    Contenido 3\r\n\r\n  </StepItem>\r\n</Step>\n```\n\n***\n\n## TABLAS\n\n| Syntax        | Description |   Test Text |\r\n| :------------ | :---------: | ----------: |\r\n| Header        |    Title    | Here's this |\r\n| Paragraph     |    Text     |    And more |\r\n| Strikethrough |             |    ~~Text~~ |\n\n| Feature       | Documentation Link |                    Notes |\r\n| :------------ | :----------------: | -----------------------: |\r\n| **Feature A** |     [Docs](#)      | For more info click here |\r\n| **Feature B** |     [Guide](#)     |  See the full guide here |\r\n| **Feature C** |     [Setup](#)     |       Setup instructions |\n\n```jsx\n\r\n| Feature       | Documentation Link |                    Notes |\r\n| :------------ | :----------------: | -----------------------: |\r\n| **Feature A** |     [Docs](#)      | For more info click here |\r\n| **Feature B** |     [Guide](#)     |  See the full guide here |\r\n| **Feature C** |     [Setup](#)     |       Setup instructions |\r\n\n```\n\n***\n\n## TABS\n\n```jsx\n<Tabs defaultValue=\"js\" className=\"pt-5 pb-1\">\r\n\r\n  <TabsList className=\"\">\r\n    <TabsTrigger value=\"js\">layout.jsx</TabsTrigger>\r\n    <TabsTrigger value=\"ts\">layout.tsx</TabsTrigger>\r\n  </TabsList>\r\n\r\n  <TabsContent value=\"js\">\r\n  '''jsx {7} showLineNumbers\r\n\r\n    // Contenido de layout.jsx\r\n\r\n  '''\r\n  </TabsContent>\r\n\r\n  <TabsContent value=\"ts\">\r\n  '''tsx {11} showLineNumbers\r\n\r\n    // Contenido de layout.tsx\r\n\r\n  '''\r\n  </TabsContent>\r\n\r\n</Tabs>\n```\n"
  },
  {
    "slug": "/dev-templates/app-documentation/rubix-documents",
    "title": "Rubix Documents",
    "description": "Este kit de inicio de documentos sirve como una base flexible y escalable para crear sitios web de documentación o proyectos basados ​​en contenido.",
    "content": "![Banner](https://vercel.com/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Fe5382hct74si%2F5nVnDsvxzCbKSnLIm6IX5W%2Faf59967eb27c0fa46fbfcc81a9c427c8%2FCleanShot_2024-09-27_at_15.59.48_2x.png\\&w=1920\\&q=75)\n\n## TEMPLATE\n\nDocuments es un potente kit de inicio de documentación de Next.js diseñado para simplificar el proceso de creación de documentación de productos, manuales técnicos y guías comerciales integrales y de alta calidad. Desarrollado con React, Tailwind CSS y TypeScript, este kit de inicio proporciona la base para crear la documentación de su proyecto y su base de conocimientos.\n\n### STACK TECNOLOGICO\n\n* **Framework**: Next.js\n* **Caso de uso**: Documentación\n* **CSS**: Tailwind\n\n### CARACTERISTICAS\n\n* **Creación de contenido**\n  * ***Integración MDX***: escriba documentos con componentes Markdown y JSX.\n  * ***Componentes personalizados***: reutilice componentes React en sus documentos.\n  * ***Diagramas de Mermaid.js***: crea diagramas de flujo y diagramas.\n  * ***Matemáticas y tablas***: incluye tablas y fórmulas matemáticas LaTeX.\n\n* **Navegación y legibilidad**\n  * ***Navegación multinivel***: páginas anidadas para crear jerarquías.\n  * ***Paginación de contenido***: transiciones fluidas entre páginas.\n  * ***Tabla de contenidos dinámica***: tabla de contenidos generada automáticamente.\n  * ***Selector de código***: alterne y copie fragmentos de código fácilmente.\n\n* **Características del código**\n  * ***Resaltado de sintaxis***: Resaltado según tema.\n  * ***Bloques de código mejorados***: Resaltado de líneas y títulos de código.\n\n* **Temas y experiencia de usuario**\n  * ***Modos claro/oscuro***: Cambio automático de tema.\n  * ***Optimización SEO***: Metadatos generados automáticamente para una mejor clasificación.\n    * Gestión de metaetiquetas (título, descripción, URL, uso compartido en redes sociales).\n\n* **Búsqueda y mejoras futuras**\n  * ***Búsqueda avanzada***: Búsqueda aproximada con resaltado de términos.\n  * ***Base de conocimiento de IA***: Futuras herramientas de documentación impulsadas por IA.\n\n### LICENCIA\n\nEste proyecto está licenciado bajo la licencia **MIT**. Consulte el archivo [LICENCIA](https://github.com/rubixvi/rubix-documents/blob/main/LICENSE) para obtener más detalles.\n\n### CONTACTO\n\nPara obtener ayuda o realizar consultas, comuníquese con Vincent Vu [@rubixvi](https://x.com/rubixvi) en X.\n\nRubix Studios: [https://www.rubixstudios.com.au](https://www.rubixstudios.com.au)\n\nProyecto: [https://github.com/rubixvi/rubix-documents](https://github.com/rubixvi/rubix-documents)\n\n***\n\n## LINKS\n\n<CardGrid>\n  <Card title=\"Template Vercel\" href=\"https://vercel.com/templates/next.js/documents-simple-next-js-documentation\" icon=\"alignJustify\" variant=\"small\" external=\"true\" />\n\n  <Card title=\"Demo\" href=\"https://rubix-documents.vercel.app/\" icon=\"alignJustify\" variant=\"small\" external=\"true\" />\n\n  <Card title=\"Repositorio GitHub\" href=\"https://github.com/rubixvi/rubix-documents\" icon=\"alignJustify\" variant=\"small\" external=\"true\" />\n</CardGrid>\n\n***\n\n## CLONAR REPOSITORIO\n\n<Step>\n  <StepItem title=\"Clonar repositorio\">\n    Clona el repositorio de GitHub y accede a la nueva carpeta del proyecto\n\n    ```bash\n    git clone https://github.com/rubixvi/rubix-documents.git\r\n    cd rubix-documents\n    ```\n  </StepItem>\n\n  <StepItem title=\"Conectar con nuevo repositorio\">\n    1. Crea un nuevo repositorio en [GitHub](https://github.com/)\n    2. Verificar qué origen tiene asignado el repositorio del proyecto\n       ```bash\n       git remote -v\n       ```\n       Esto mostrará una respuesta como la siguiente:\n       ```bash\n       origin  <URL REPO ASIGNADO> (fetch)\r\n       origin  <URL REPO ASIGNADO> (push)\n       ```\n    3. Ejectura el comando de reasignación de Origen del proyecto con el siguiente comando:\n       ```bash\n       git remote set-url origin <NUEVA_URL>\n       ```\n  </StepItem>\n\n  <StepItem title=\"Instalar dependencias\">\n    Instala todas las dependencias del proyecto\n\n    ```bash\n    npm install\n    ```\n  </StepItem>\n\n  <StepItem title=\"Correr el servidor\">\n    * **Ejecutar en modo desarrollo**:\n\n      ```bash\n      npm run dev\n      ```\n\n    * **Ejecutar en modo producción**:\n      1. Construir aplicación:\n      ```bash\n      npm run build\n      ```\n      2. Ejecutar en modo producción:\r\n         Construir aplicación:\n      ```bash\n      npm run start\n      ```\n  </StepItem>\n</Step>\n"
  },
  {
    "slug": "/dev-templates/app-landingpages",
    "title": "Landing Pages",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/dev-templates/app-saas",
    "title": "Aplicaciones SaaS",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/dev-templates",
    "title": "Templates de desarrollo",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/documentation",
    "title": "Sobre documentación",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/documentation/installation",
    "title": "Uso",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/frameworks",
    "title": "Frameworks para desarrollo",
    "description": "Desc",
    "content": ""
  },
  {
    "slug": "/frameworks/nextjs",
    "title": "Next.js",
    "description": "Esta",
    "content": ""
  },
  {
    "slug": "/programming/git/commands",
    "title": "Comandos de Git",
    "description": "Exploración detallada de los comandos de Git esenciales para la gestión de versiones en proyectos de software.",
    "content": "La sección de comandos de Git es el corazón de la herramienta.  Permite controlar el versionado de tu código. Comandos como `add`, `commit`, `push`, `pull`, `branch`, `merge`, y `rebase` son esenciales.  `add` prepara cambios, `commit` guarda esos cambios localmente, `push` sube los cambios a un repositorio remoto, `pull` descarga los cambios remotos, `branch` crea ramificaciones para desarrollo paralelo, y `merge` y `rebase` integran cambios de diferentes ramas. Dominar estos comandos es clave para una gestión eficiente del código con Git.\n\n## COMANDOS FUNDAMENTALES DE GIT\n\nA continuación, se describen los comandos de Git más utilizados, agrupados por su función principal:\n\n### 1. CONFIGURACION E INICIALIZACION\n\n* **`git config`**:  Configura las opciones de Git, como el nombre de usuario, el correo electrónico, el editor de texto predeterminado, etc.  Se puede configurar a nivel local (para un solo repositorio), global (para todos los repositorios del usuario) o de sistema (para todos los usuarios del sistema).\n\n  ```bash\n  git config --global user.name \"Tu Nombre\"\r\n  git config --global user.email \"tu_correo@ejemplo.com\"\n  ```\n\n* **`git init`**:  Inicializa un nuevo repositorio de Git en el directorio actual.  Crea un directorio oculto `.git` que contiene la información de configuración del repositorio.\n\n  ```bash\n  git init\n  ```\n\n* **`git clone`**:  Crea una copia local de un repositorio remoto existente. Descarga todos los archivos y el historial completo del repositorio.\n\n  ```bash\n  git clone https://github.com/usuario/repositorio.git\n  ```\n\n### 2.  GESTION DE CAMBIOS\n\n* **`git status`**:  Muestra el estado actual del repositorio, incluyendo los archivos modificados, los archivos en stage (preparados para el commit) y los archivos sin seguimiento.\n\n  ```bash\n  git status\n  ```\n\n* **`git add`**:  Añade los archivos modificados al área de stage (staging area).  El área de stage es una zona intermedia donde se preparan los cambios que se van a incluir en el próximo commit.\n\n  ```bash\n  git add archivo.txt\r\n  git add .  # Añade todos los archivos modificados\n  ```\n\n* **`git commit`**:  Guarda los cambios que están en el área de stage en el historial del repositorio.  Cada commit tiene un mensaje descriptivo que explica los cambios realizados.\n\n  ```bash\n  git commit -m \"Mensaje descriptivo del commit\"\n  ```\n\n* **`git rm`**:  Elimina un archivo del repositorio y del sistema de archivos.\n\n  ```bash\n  git rm archivo.txt\r\n  git commit -m \"Elimina archivo.txt\"\n  ```\n\n* **`git mv`**:  Renombra o mueve un archivo en el repositorio.\n\n  ```bash\n  git mv archivo_viejo.txt archivo_nuevo.txt\r\n  git commit -m \"Renombra archivo_viejo.txt a archivo_nuevo.txt\"\n  ```\n\n### 3.  RAMAS (BRANCHES)\n\n* **`git branch`**:  Lista, crea o elimina ramas. Una rama es una línea de desarrollo independiente del tronco principal (master o main).\n\n  ```bash\n  git branch  # Lista las ramas locales\r\n  git branch nueva_rama  # Crea una nueva rama llamada \"nueva_rama\"\r\n  git branch -d rama_a_eliminar # Elimina una rama (si ya se ha fusionado)\r\n  git branch -D rama_a_eliminar # Elimina una rama (forzando la eliminación)\n  ```\n\n* **`git checkout`**:  Cambia entre ramas.  Permite trabajar en diferentes líneas de desarrollo sin afectar la rama principal.\n\n  ```bash\n  git checkout nueva_rama  # Cambia a la rama \"nueva_rama\"\r\n  git checkout -b nueva_rama # Crea y cambia a la rama \"nueva_rama\"\n  ```\n\n* **`git merge`**:  Fusiona los cambios de una rama en otra.  Combina el historial de las dos ramas.\n\n  ```bash\n  git checkout master\r\n  git merge nueva_rama # Fusiona los cambios de \"nueva_rama\" en \"master\"\n  ```\n\n* **`git rebase`**:  Integra los cambios de una rama en otra moviendo la base de la rama actual a la base de la otra rama.  Produce un historial más limpio que `git merge`, pero puede ser más complejo de usar y potencialmente peligroso si no se entiende bien.\n\n  ```bash\n  git checkout nueva_rama\r\n  git rebase master # Mueve la base de \"nueva_rama\" a la última versión de \"master\"\n  ```\n\n### 4.  TRABAJO REMOTO\n\n* **`git remote add <nombre> <url>`**:  Añade una nueva conexión a un repositorio remoto.  `<nombre>` es un alias que le das al repositorio remoto (por ejemplo, `origin`, `upstream`).  `<url>` es la URL del repositorio remoto (por ejemplo, `https://github.com/usuario/repositorio.git`).\n\n  ```bash\n  git remote add origin https://github.com/usuario/repositorio.git\r\n  git remote add upstream https://github.com/otro_usuario/repositorio.git\n  ```\n\n  ```\n  ```\n\n* **`git remote rename <viejo_nombre> <nuevo_nombre>`**:  Renombra una conexión remota existente.\n\n  ```bash\n  git remote rename origin nuevo_origin\n  ```\n\n* **`git remote remove <nombre>` o `git remote rm <nombre>`**:  Elimina una conexión remota.\n\n  ```bash\n  git remote remove origin\n  ```\n\n* **`git remote set-url <nombre> <nueva_url>`**:  Cambia la URL asociada a una conexión remota existente.\n\n  ```bash\n  git remote set-url origin https://nuevo_dominio/usuario/repositorio.git\n  ```\n\n* **`git remote show <nombre>`**:  Muestra información detallada sobre una conexión remota específica, incluyendo la URL, las ramas rastreadas, las ramas locales que están configuradas para hacer push a ese remoto, y más.\n\n  ```bash\n  git remote show origin\n  ```\n\n* **`git remote update <nombre>`**:  Descarga información actualizada sobre las ramas y etiquetas del repositorio remoto especificado, sin fusionar los cambios en tus ramas locales.  Es similar a `git fetch`, pero se centra en actualizar la información de seguimiento de las ramas remotas.\n\n  ```bash\n  git remote update origin\n  ```\n\n* **`git remote prune <nombre>`**:  Elimina las referencias a ramas remotas que ya no existen en el repositorio remoto.  Esto ayuda a mantener tu repositorio local limpio y actualizado.\n\n  ```bash\n  git remote prune origin\n  ```\n\n* **`git fetch`**:  Descarga los cambios de un repositorio remoto sin fusionarlos en la rama local.  Permite inspeccionar los cambios antes de integrarlos.\n\n  ```bash\n  git fetch origin\n  ```\n\n* **`git pull`**:  Descarga los cambios de un repositorio remoto y los fusiona automáticamente en la rama local.  Es una combinación de `git fetch` y `git merge`.\n\n  ```bash\n  git pull origin master # Descarga y fusiona los cambios de la rama \"master\" del repositorio \"origin\"\n  ```\n\n* **`git push`**:  Sube los cambios de la rama local a un repositorio remoto.\n\n  ```bash\n  git push origin master # Sube los cambios de la rama \"master\" al repositorio \"origin\"\r\n  git push -u origin master # Establece el rastreo entre la rama local y la rama remota (solo la primera vez)\n  ```\n\n### 5.  DESHACER CAMBIOS\n\n* **`git reset`**:  Revierte el estado del repositorio a un commit anterior.  Puede modificar el área de stage, los archivos modificados o incluso el historial del repositorio, dependiendo del tipo de reset que se utilice.\n\n  * `git reset --soft <commit>`:  Mueve el HEAD al commit especificado, pero mantiene los cambios en el área de stage.\n  * `git reset --mixed <commit>`:  Mueve el HEAD al commit especificado y elimina los cambios del área de stage, dejándolos como archivos modificados.  (Este es el comportamiento predeterminado si no se especifica ningún tipo).\n  * `git reset --hard <commit>`:  Mueve el HEAD al commit especificado y descarta todos los cambios en el área de stage y los archivos modificados.  ¡PELIGRO!  Esta opción puede provocar la pérdida de datos si no se usa con cuidado.\n\n  ```bash\n  git reset --soft HEAD^ # Revierte al commit anterior (mantiene los cambios en stage)\r\n  git reset --hard  a1b2c3d # Revierte al commit con hash a1b2c3d (descarta todos los cambios)\n  ```\n\n* **`git revert`**:  Crea un nuevo commit que deshace los cambios introducidos por un commit anterior.  No modifica el historial existente, sino que añade un nuevo commit que revierte los cambios.  Es una forma segura de deshacer cambios, ya que no altera el historial.\n\n  ```bash\n  git revert a1b2c3d # Crea un nuevo commit que deshace los cambios del commit con hash a1b2c3d\n  ```\n\n### 6. OTROS COMANDOS UTILES\n\n* **`git log`**:  Muestra el historial de commits del repositorio. Permite ver la fecha, el autor, el mensaje y el hash de cada commit.\n\n  ```bash\n  git log\r\n  git log --oneline # Muestra el historial en una sola línea por commit\r\n  git log --graph # Muestra el historial como un gráfico\r\n  git log --author=\"Tu Nombre\" # Muestra los commits realizados por un autor específico\n  ```\n\n  Para salir de `git log`, solo basta presionar la letra ***Q***.\n\n* **`git diff`**:  Muestra las diferencias entre archivos, commits o ramas.\n\n  ```bash\n  git diff # Muestra las diferencias entre el área de stage y los archivos modificados\r\n  git diff HEAD # Muestra las diferencias entre el último commit y los archivos modificados\r\n  git diff rama1 rama2 # Muestra las diferencias entre las ramas rama1 y rama2\n  ```\n\n* **`git stash`**:  Guarda temporalmente los cambios no confirmados.  Permite cambiar de rama o realizar otras tareas sin tener que hacer commit de los cambios incompletos.\n\n  ```bash\n  git stash # Guarda los cambios no confirmados\r\n  git stash pop # Recupera los últimos cambios guardados\r\n  git stash list # Lista los stashes guardados\r\n  git stash apply stash@{2} # Aplica un stash específico\n  ```\n\n* **`.gitignore`**:  Un archivo que especifica los archivos y directorios que Git debe ignorar.  Es útil para evitar que archivos temporales, archivos de configuración o archivos generados automáticamente se incluyan en el repositorio.\n\n  ```text\n  # Ejemplo de archivo .gitignore\r\n  *.log\r\n  tmp/\r\n  config.ini\n  ```\n"
  },
  {
    "slug": "/programming/git/github",
    "title": "GitHub",
    "description": "Plataforma de desarrollo colaborativo basada en la nube para el control de versiones con Git.",
    "content": "GitHub es una plataforma de desarrollo colaborativo basada en la nube que permite a los desarrolladores almacenar, gestionar y controlar las versiones de su código. Es una herramienta esencial en el mundo del desarrollo de software moderno, facilitando la colaboración, el seguimiento de cambios y la gestión de proyectos de cualquier tamaño. GitHub se basa en el sistema de control de versiones distribuido Git, lo que significa que cada desarrollador tiene una copia completa del repositorio del proyecto en su máquina local, permitiendo trabajar de forma offline y sincronizar los cambios posteriormente.\n\n### HISTORIA\n\nGitHub fue fundado en 2008 por Tom Preston-Werner, Chris Wanstrath, PJ Hyett y Scott Chacon. La idea surgió de la necesidad de una plataforma que facilitara la colaboración entre desarrolladores utilizando Git. Antes de GitHub, Git era utilizado principalmente a través de la línea de comandos, lo que podía ser intimidante para algunos. GitHub proporcionó una interfaz web intuitiva y características adicionales que hicieron que Git fuera más accesible y atractivo para una audiencia más amplia.\n\nLa plataforma rápidamente ganó popularidad en la comunidad de código abierto, convirtiéndose en el hogar de miles de proyectos. En 2018, Microsoft adquirió GitHub por 7.5 mil millones de dólares, una decisión que generó tanto entusiasmo como preocupación en la comunidad. Sin embargo, Microsoft ha mantenido su compromiso de apoyar el código abierto y ha continuado invirtiendo en la plataforma, mejorando sus características y servicios.\n\n### OBJETIVOS CLAVE\n\n* **Control de Versiones:** GitHub permite a los desarrolladores realizar un seguimiento de todos los cambios realizados en el código a lo largo del tiempo. Esto facilita la identificación y corrección de errores, la reversión a versiones anteriores y la comprensión de la evolución del proyecto.\n* **Colaboración:** GitHub facilita la colaboración entre desarrolladores, permitiendo que varios miembros del equipo trabajen en el mismo proyecto simultáneamente. A través de características como pull requests y issues, los desarrolladores pueden revisar el código de otros, discutir cambios y contribuir al proyecto de manera organizada.\n* **Gestión de Proyectos:** GitHub proporciona herramientas para la gestión de proyectos, como la capacidad de crear y asignar tareas, establecer hitos y realizar un seguimiento del progreso. Esto ayuda a los equipos a mantenerse organizados y a cumplir con los plazos.\n* **Descubrimiento de Código:** GitHub es una plataforma donde los desarrolladores pueden descubrir y explorar proyectos de código abierto. Esto fomenta el aprendizaje, la reutilización de código y la contribución a la comunidad.\n* **Automatización:** GitHub Actions permite automatizar tareas de desarrollo de software, como pruebas, integración continua y despliegue. Esto ayuda a los equipos a mejorar la eficiencia y la calidad de su trabajo.\n\n### CARACTERISTICAS PRINCIPALES\n\n* **Repositorios:** Los repositorios son el corazón de GitHub. Un repositorio es un directorio donde se almacenan todos los archivos de un proyecto, junto con el historial de cambios. Los repositorios pueden ser públicos (accesibles para todos) o privados (accesibles solo para los miembros del equipo).\n* **Branches:** Las branches (ramas) permiten a los desarrolladores trabajar en nuevas características o correcciones de errores sin afectar la rama principal del proyecto (generalmente llamada \"main\" o \"master\"). Una vez que los cambios están listos, se pueden fusionar (merge) de nuevo en la rama principal.\n* **Commits:** Un commit es una instantánea de los cambios realizados en el código en un momento dado. Cada commit tiene un mensaje que describe los cambios realizados.\n* **Pull Requests:** Los pull requests (solicitudes de extracción) son una forma de proponer cambios a un repositorio. Un desarrollador crea una branch, realiza los cambios necesarios y luego envía un pull request para que otros miembros del equipo revisen el código.\n* **Issues:** Los issues (problemas) se utilizan para realizar un seguimiento de errores, solicitar nuevas características o discutir ideas. Los issues pueden ser asignados a miembros del equipo, etiquetados y cerrados una vez que se han resuelto.\n* **Forking:** Forking permite a los desarrolladores crear una copia de un repositorio en su propia cuenta. Esto les permite realizar cambios en el código sin afectar el repositorio original. Si desean contribuir con sus cambios al repositorio original, pueden enviar un pull request.\n* **GitHub Actions:** GitHub Actions es una plataforma de automatización que permite a los desarrolladores crear flujos de trabajo personalizados para automatizar tareas de desarrollo de software.\n\n### FLUJO DE TRABAJO TIPICO\n\n1. **Crear un Repositorio:** El primer paso es crear un repositorio en GitHub para el proyecto.\n2. **Clonar el Repositorio:** Clonar el repositorio en la máquina local del desarrollador utilizando el comando `git clone`.\n3. **Crear una Branch:** Crear una nueva branch para trabajar en una nueva característica o corrección de errores.\n4. **Realizar Cambios:** Realizar los cambios necesarios en el código.\n5. **Commit los Cambios:** Commit los cambios con un mensaje descriptivo utilizando el comando `git commit`.\n6. **Subir los Cambios:** Subir los cambios a la branch remota en GitHub utilizando el comando `git push`.\n7. **Crear un Pull Request:** Crear un pull request para que otros miembros del equipo revisen el código.\n8. **Revisar el Código:** Los miembros del equipo revisan el código y proporcionan comentarios.\n9. **Fusionar el Pull Request:** Una vez que el código ha sido aprobado, el pull request se puede fusionar en la rama principal.\n\n### INFORMACION ADICIONAL\n\n* GitHub ofrece una variedad de planes de precios, incluyendo un plan gratuito para proyectos públicos y planes de pago para proyectos privados con características adicionales.\n* GitHub tiene una gran comunidad de usuarios y una amplia documentación disponible en su sitio web.\n* GitHub se integra con una variedad de herramientas y servicios de desarrollo de software, como IDEs, herramientas de integración continua y plataformas de despliegue.\n\nEn resumen, GitHub es una plataforma esencial para el desarrollo de software moderno, que facilita la colaboración, el control de versiones y la gestión de proyectos. Su amplia gama de características y su gran comunidad de usuarios la convierten en una herramienta indispensable para cualquier desarrollador.\n"
  },
  {
    "slug": "/programming/git/gitignore",
    "title": ".gitignore",
    "description": "Archivo de configuración para especificar archivos y directorios que Git debe ignorar.",
    "content": "El archivo `.gitignore` es un archivo de texto plano que reside en el directorio raíz de un repositorio Git. Su propósito principal es decirle a Git qué archivos y directorios no deben ser rastreados ni incluidos en los commits. Esto es crucial para mantener un repositorio limpio, evitar la inclusión de archivos sensibles (como contraseñas o claves privadas), y optimizar el rendimiento de Git al reducir la cantidad de archivos que necesita monitorear.\n\nEl archivo `.gitignore` utiliza patrones para especificar qué archivos y directorios deben ser ignorados. Estos patrones pueden ser nombres de archivos específicos, nombres de directorios, o patrones más generales utilizando comodines. Git evalúa estos patrones en orden, y si un archivo o directorio coincide con un patrón en `.gitignore`, se ignora.\n\n## FUNCIONAMIENTO BASICO\n\n1. **Ubicación:** El archivo `.gitignore` se coloca en el directorio raíz del repositorio. También se pueden crear archivos `.gitignore` en subdirectorios para aplicar reglas de ignorado específicas a esas carpetas. Las reglas en un archivo `.gitignore` de un subdirectorio tienen precedencia sobre las reglas en el archivo `.gitignore` del directorio raíz.\n\n2. **Sintaxis:** La sintaxis del archivo `.gitignore` es sencilla:\n\n   * Cada línea representa un patrón.\n   * Las líneas que comienzan con `#` son comentarios y se ignoran.\n   * Las líneas en blanco también se ignoran.\n   * Se pueden usar comodines para crear patrones más generales:\n     * `*`: Coincide con cero o más caracteres.\n     * `?`: Coincide con un solo carácter.\n     * `[]`: Coincide con un rango de caracteres.\n     * `**`: Coincide con cualquier número de directorios.\n   * Un prefijo `!` niega un patrón. Es decir, si un archivo coincide con un patrón negado, se incluirá incluso si coincide con un patrón anterior.\n   * Un `/` al final de un patrón indica que solo debe coincidir con un directorio.\n\n3. **Prioridad:** Git evalúa las reglas de ignorado en el siguiente orden:\n\n   1. Reglas leídas desde la línea de comandos (`git add -f`).\n   2. Reglas en el archivo `.gitignore` en el mismo directorio que el archivo o en cualquier directorio padre.\n   3. Reglas especificadas en el archivo `$GIT_DIR/info/exclude`.\n   4. Reglas especificadas en la configuración global de Git (core.excludesfile).\n\n## EJEMPLOS DE IMPLEMENTACION\n\nAquí hay algunos ejemplos de cómo usar `.gitignore`:\n\n1. **Ignorar archivos `.log`:**\n\n   ```\n   *.log\n   ```\n\n   Esto ignorará todos los archivos que tengan la extensión `.log` en cualquier directorio del repositorio.\n\n2. **Ignorar el directorio `node_modules`:**\n\n   ```\n   node_modules/\n   ```\n\n   Esto ignorará el directorio `node_modules` y todo su contenido.\n\n3. **Ignorar archivos `.DS_Store` (comunes en macOS):**\n\n   ```\n   .DS_Store\n   ```\n\n   Esto ignorará los archivos `.DS_Store` que macOS crea en cada directorio.\n\n4. **Ignorar todos los archivos `.txt` excepto `important.txt`:**\n\n   ```\n   *.txt\r\n   !important.txt\n   ```\n\n   Esto ignorará todos los archivos `.txt` excepto el archivo `important.txt`.\n\n5. **Ignorar un directorio específico y todos sus subdirectorios:**\n\n   ```\n   build/\n   ```\n\n   Esto ignorará el directorio `build` y todos sus subdirectorios y archivos.\n\n6. **Ignorar archivos de configuración locales:**\n\n   ```\n   config/local_settings.py\n   ```\n\n   Esto ignorará el archivo `local_settings.py` dentro del directorio `config`.\n\nEn resumen, el archivo `.gitignore` es una herramienta esencial para cualquier proyecto Git. Su uso adecuado ayuda a mantener el repositorio limpio, seguro y eficiente, facilitando la colaboración y el desarrollo a largo plazo.\n"
  },
  {
    "slug": "/programming/git",
    "title": "Git",
    "description": "Git es un sistema de control de versiones distribuido que rastrea los cambios en archivos y coordina el trabajo entre múltiples personas. Permite a los desarrolladores (y a cualquier persona) gestionar el historial de sus proyectos, colaborar fácilmente y revertir a versiones anteriores si es necesario. Cada persona tiene una copia completa del proyecto, lo que permite trabajar sin conexión y reduce la dependencia de un servidor central. Es la herramienta estándar para el desarrollo de software colaborativo moderno.",
    "content": "![GIT](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Git-logo.svg/800px-Git-logo.svg.png)\n\n## ¿QUE ES GIT?\n\nGit es un sistema de control de versiones distribuido (DVCS) diseñado para rastrear los cambios en archivos de computadora y coordinar el trabajo en esos archivos entre múltiples personas. En esencia, es una herramienta que permite a los desarrolladores gestionar el código fuente de manera eficiente y colaborativa, pero se puede usar para rastrear cambios en cualquier tipo de archivo (documentos, imágenes, configuraciones, etc.).\n\n### CARACTERISTICAS CLAVES\n\n* **Sistema de Control de Versiones Distribuido**: A diferencia de los sistemas centralizados (como Subversion o CVS), Git permite que cada desarrollador tenga una copia completa del repositorio, incluyendo todo el historial de cambios. Esto ofrece varias ventajas:\n\n* **Trabajo Offline**: Los desarrolladores pueden trabajar y hacer commits localmente sin necesidad de una conexión constante al servidor central.\n\n* **Rendimiento**: Las operaciones locales (como ver el historial o hacer commits) son mucho más rápidas, ya que no requieren acceso a la red.\n\n* **Resiliencia**: Si el servidor central falla, el proyecto no se pierde, ya que cada desarrollador tiene una copia completa.\n\n* **Ramas (Branching) y Combinación (Merging)**: Git facilita la creación de ramas (líneas de desarrollo paralelas) para implementar nuevas funcionalidades, corregir errores o experimentar con ideas. Luego, estas ramas se pueden combinar (merge) de nuevo en la rama principal. Este modelo de branching permite un flujo de trabajo flexible y no lineal.\n\n* **Eficiencia**: Git está diseñado para ser rápido y eficiente, incluso con proyectos muy grandes. Utiliza algoritmos de compresión y almacenamiento de datos inteligentes para minimizar el espacio en disco y el tiempo de acceso.\n\n* **Integridad de Datos**: Git utiliza un algoritmo de hash SHA-1 para identificar y rastrear cada cambio. Esto garantiza la integridad de los datos y detecta cualquier corrupción accidental.\n\n* **Área de Preparación (Staging Area)**: Git tiene un área de preparación intermedia entre el directorio de trabajo y el repositorio. Esto permite seleccionar los cambios específicos que se incluirán en el próximo commit, ofreciendo un control más granular sobre el historial.\n\n* **Gratuito y de Código Abierto**: Git es un proyecto de código abierto licenciado bajo la GPLv2, lo que significa que es gratuito para usar, modificar y distribuir.\n\n### OBJETIVOS DE GIT\n\n* **Control de Versiones**: Rastrear todos los cambios realizados en los archivos a lo largo del tiempo, permitiendo volver a versiones anteriores, comparar diferencias y auditar modificaciones.\n\n* **Colaboración**: Facilitar el trabajo en equipo en proyectos de software, permitiendo a múltiples desarrolladores trabajar simultáneamente en el mismo código base sin conflictos.\n\n* **Gestión de Ramas**: Proporcionar un modelo flexible para crear, combinar y gestionar ramas de desarrollo, lo que permite experimentar con nuevas funcionalidades sin afectar la estabilidad del proyecto principal.\n\n* **Desarrollo Paralelo**: Permitir que varios desarrolladores trabajen en diferentes partes del proyecto al mismo tiempo, sin interferir entre sí.\n\n* **Deshacer Cambios**: Ofrecer herramientas para deshacer cambios, revertir a versiones anteriores y corregir errores.\n\n* **Seguridad**: Garantizar la integridad de los datos y prevenir la pérdida de información.\n\n* **Auditoría**: Facilitar el seguimiento de quién hizo qué cambios y cuándo.\n\n* **Gestión de Grandes Proyectos**: Escalar bien para proyectos de software de gran tamaño con muchos archivos y un historial de cambios extenso.\n\n## INSTALACION\n\nLa instalación de Git varía dependiendo de tu sistema operativo. Aquí tienes las instrucciones para los sistemas más comunes:\n\n### 1. WINDOWS\n\n* **Descargar**: Descarga el instalador de Git para Windows desde el sitio web oficial: [https://git-scm.com/download/win](https://git-scm.com/download/win)\n\n* **Ejecutar**: Ejecuta el archivo descargado. Sigue los pasos del asistente de instalación. Puedes aceptar las opciones por defecto en la mayoría de los casos.\n\n* **Editor de Texto**: El instalador te preguntará qué editor de texto quieres usar con Git (por ejemplo, Notepad++, Visual Studio Code, Vim). Elige el que prefieras. Si no estás seguro, puedes dejar el valor por defecto (que suele ser Vim).\n\n* **Ajuste del PATH**: Asegúrate de que la opción \"Use Git from Git Bash only\" NO esté seleccionada, a menos que estés seguro de que solo quieres usar Git desde la línea de comandos de Git Bash. La opción recomendada es \"Git from the command line and also from 3rd-party software\".\n\n* **Terminal**: Puedes elegir el emulador de terminal que quieres usar con Git Bash (MinTTY o el terminal de Windows predeterminado).\n\n* **Verificar Instalación**: Abre una ventana de símbolo del sistema (cmd) o PowerShell y escribe git --version. Si Git está instalado correctamente, mostrará la versión instalada.\n\n### 2. MACOS\n\n1. ***Opción 1*** - Instalador (Recomendado)\n\n   * **Descargar**: Descarga el instalador de Git para macOS desde el sitio web oficial: [https://git-scm.com/download/mac](https://git-scm.com/download/mac)\n\n   * **Ejecutar**: Ejecuta el archivo descargado (normalmente un archivo .dmg), sigue las instrucciones del instalador.\n\n   * **Verificar**: Verifica la instalación abriendo una Terminal y escribiendo git --version.\n\n2. ***Opción 2*** - Homebrew\n\n   Si tienes Homebrew instalado, puedes instalar Git con el siguiente comando:\n\n   ```bash\n   brew install git\n   ```\n\n   * **Verificar**: Verifica la instalación abriendo una Terminal y escribiendo git --version.\n\n3. ***Opción 3*** - Xcode Command Line Tools\n\n   Si tienes Xcode instalado, Git puede ya estar presente como parte de las *Command Line Tools*. Abre la Terminal y escribe lo siguiente.\n\n   ```bash\n   git --version\n   ```\n\n   Si no está instalado, *macOS* te pedirá que instales las *Command Line Tools*.\n\n### 3. LINUX (Debian/Ubuntu)\n\nAbre una terminal y ejecuta el siguiente comando.\n\n```bash\nsudo apt update\r\nsudo apt install git\n```\n\nConfirma la instalación escribiendo.\n\n```bash\ngit --version\n```\n\n### 4. LINUX (Fedora/CentOS/RHEL):\n\nAbre una terminal y ejecuta el siguiente comando.\n\n```bash\nsudo dnf install git\r\n# o en sistemas más antiguos:\r\n# sudo yum install git\n```\n\nConfirma la instalación escribiendo.\n\n```bash\ngit --version\n```\n\n## CONFIGURACION INICIAL\n\nDespués de instalar Git, es importante configurar tu nombre de usuario y dirección de correo electrónico, ya que esta información se asociará con tus *commits*, reemplaza ***\"Tu Nombre\"*** y ***\"tu@email.com\"*** con tu información real. La opción `--global` guarda esta configuración para todos tus repositorios Git.\n\n```bash\ngit config --global user.name <tu nombre>\r\ngit config --global user.email <tu@email.com>\n```\n\nPuedes verificar tu configuración con los siguientes comandos\n\n```bash\ngit config --global user.name\r\ngit config --global user.email\n```\n"
  },
  {
    "slug": "/programming",
    "title": "Herramientas de Programación",
    "description": "Una visión general de los lenguajes de programación, su historia, tipos, paradigmas y ejemplos.",
    "content": ""
  },
  {
    "slug": "/programming/languages/bestpp",
    "title": "Lenguajes de programación",
    "description": "Esta sección proporciona una descripción general de cómo comenzar a utilizar Documents, Kit de inicio de documentos de Next.js.",
    "content": ""
  },
  {
    "slug": "/programming/languages/dart",
    "title": "Lenguajes de programación",
    "description": "Esta sección proporciona una descripción general de cómo comenzar a utilizar Documents, Kit de inicio de documentos de Next.js.",
    "content": ""
  },
  {
    "slug": "/programming/languages",
    "title": "Lenguajes de Programación",
    "description": "Una visión general de los lenguajes de programación, su historia, tipos, paradigmas y ejemplos.",
    "content": "## ¿QUE SON LOS LENGUAJES DE PROGRAMACION?\n\nUn **lenguaje de programación** es un sistema formal diseñado para expresar computaciones que pueden ser realizadas por una máquina, como una computadora. Permite a los programadores comunicar instrucciones a las computadoras en un formato que estas puedan entender y ejecutar.  En esencia, un lenguaje de programación actúa como un intermediario entre el pensamiento humano y la lógica binaria de las máquinas.\n\n### HISTORIA\n\nLa historia de los lenguajes de programación es tan antigua como la de las propias computadoras.\n\n* **Inicios (Década de 1940-1950):**  Las primeras computadoras se programaban directamente en código máquina, utilizando secuencias de 0s y 1s. Esto era extremadamente tedioso y propenso a errores.  Un hito importante fue la creación de **Short Code** en 1949, considerado uno de los primeros lenguajes de programación de alto nivel, aunque requería interpretación en cada ejecución.  **A-0** (1951) fue otro sistema temprano que facilitó la programación al permitir la especificación de operaciones mediante códigos numéricos.\n* **La Era de los Primeros Lenguajes de Alto Nivel (Década de 1950):**  La necesidad de simplificar la programación llevó al desarrollo de los primeros lenguajes de alto nivel.  **FORTRAN** (Formula Translation, 1957), creado por John Backus en IBM, fue diseñado para cálculos científicos e ingeniería.  **LISP** (List Processor, 1958), desarrollado por John McCarthy en el MIT, se centró en el procesamiento de listas y se convirtió en el lenguaje preferido para la investigación en inteligencia artificial.  **COBOL** (Common Business-Oriented Language, 1959), creado por Grace Hopper, se orientó a aplicaciones empresariales y procesamiento de datos.\n* **La Expansión y Diversificación (Década de 1960-1970):**  Esta época vio una explosión en la creación de lenguajes.  **ALGOL** (Algorithmic Language, 1960) influyó en el diseño de muchos lenguajes posteriores.  **BASIC** (Beginner's All-purpose Symbolic Instruction Code, 1964) fue diseñado para ser fácil de aprender y usar.  **Simula 67** introdujo conceptos de programación orientada a objetos.  **Pascal** (1970), creado por Niklaus Wirth, se diseñó para la enseñanza de la programación estructurada.  **C** (1972), desarrollado por Dennis Ritchie en Bell Labs, se convirtió en un lenguaje poderoso y versátil para la programación de sistemas.\n* **La Programación Orientada a Objetos (Década de 1980-1990):**  La programación orientada a objetos (POO) ganó popularidad.  **Smalltalk** (década de 1970, pero popularizado en los 80) fue uno de los primeros lenguajes puramente orientados a objetos.  **C++** (1983) añadió características de POO a C.  **Objective-C** se utilizó ampliamente en el desarrollo de software para Apple.\n* **La Era de Internet y los Lenguajes de Scripting (Década de 1990-2000):**  El auge de Internet impulsó la creación de lenguajes de scripting.  **Python** (1991), creado por Guido van Rossum, se destacó por su legibilidad y versatilidad.  **Java** (1995), desarrollado por Sun Microsystems, se diseñó para ser multiplataforma (\"escribe una vez, ejecuta en cualquier lugar\").  **JavaScript** (1995) se convirtió en el lenguaje estándar para la programación del lado del cliente en la web.  **PHP** (1995) se popularizó para el desarrollo de aplicaciones web dinámicas.\n* **El Siglo XXI: Diversificación y Especialización:**  La tendencia hacia la diversificación continúa.  **C#** (2000), desarrollado por Microsoft, se integra estrechamente con la plataforma .NET.  **Ruby** (1995) ganó popularidad con el framework Ruby on Rails.  **Go** (2009), desarrollado por Google, se diseñó para la programación de sistemas concurrentes.  **Swift** (2014), desarrollado por Apple, reemplazó a Objective-C como el lenguaje principal para el desarrollo de iOS y macOS.  **Kotlin** (2011) se ha convertido en un lenguaje popular para el desarrollo de Android.  Además, han surgido lenguajes especializados para áreas como ciencia de datos (R), aprendizaje automático (TensorFlow, PyTorch) y computación cuántica (Q#).\n\n### OBJETIVOS CLAVE\n\n* **Expresividad:**  Permitir a los programadores expresar algoritmos y lógica de manera clara y concisa.\n* **Legibilidad:**  Facilitar la comprensión del código por parte de otros programadores (y por el propio programador en el futuro).\n* **Eficiencia:**  Permitir la creación de programas que se ejecuten de manera rápida y utilicen los recursos de la computadora de manera eficiente.\n* **Portabilidad:**  Permitir que los programas se ejecuten en diferentes plataformas (sistemas operativos, arquitecturas de hardware) sin necesidad de modificaciones significativas.\n* **Confiabilidad:**  Facilitar la creación de programas que funcionen correctamente y sean robustos ante errores.\n* **Mantenibilidad:**  Facilitar la modificación y actualización del código a lo largo del tiempo.\n\n### TIPOS DE LENGUAJES DE PROGRAMACION\n\nLos lenguajes de programación se pueden clasificar de diversas maneras:\n\n* **Por Nivel de Abstracción:**\n  * **Lenguajes de Bajo Nivel:**  Están más cerca del hardware de la computadora.  Ejemplos:  Ensamblador, código máquina.  Ofrecen un control preciso sobre el hardware, pero son difíciles de programar.\n  * **Lenguajes de Alto Nivel:**  Son más abstractos y fáciles de usar.  Ejemplos:  Python, Java, C++.  Ofrecen mayor portabilidad y productividad, pero pueden ser menos eficientes en algunos casos.\n* **Por Paradigma de Programación:**\n  * **Imperativos:**  Describen *cómo* se debe realizar un cálculo, especificando una secuencia de instrucciones.  Ejemplos:  C, Pascal, FORTRAN.\n  * **Declarativos:**  Describen *qué* se debe calcular, sin especificar los detalles de la implementación.  Ejemplos:  SQL, Prolog, Haskell.\n  * **Orientados a Objetos:**  Organizan el código en torno a \"objetos\" que encapsulan datos y comportamiento.  Ejemplos:  Java, C++, Python, C#.\n  * **Funcionales:**  Basados en el concepto de funciones matemáticas.  Ejemplos:  Haskell, Lisp, Scala.\n* **Por Propósito:**\n  * **De Propósito General:**  Se pueden utilizar para una amplia variedad de tareas.  Ejemplos:  Python, Java, C++.\n  * **De Propósito Específico:**  Diseñados para tareas específicas.  Ejemplos:  SQL (bases de datos), R (estadística), MATLAB (cálculo numérico).\n* **Por Tipo de Ejecución:**\n  * **Compilados:**  El código fuente se traduce a código máquina ejecutable antes de la ejecución.  Ejemplos:  C, C++, Go.\n  * **Interpretados:**  El código fuente se ejecuta directamente por un intérprete, línea por línea.  Ejemplos:  Python, JavaScript, PHP.\n  * **Híbridos:**  Utilizan una combinación de compilación e interpretación.  Ejemplo:  Java (el código se compila a bytecode, que luego se interpreta por la JVM).\n\n### PARADIGMAS DE PROGRAMACION\n\nUn **paradigma de programación** es un estilo o \"filosofía\" de programación.  Define cómo se estructura y organiza el código.  Algunos de los paradigmas más comunes son:\n\n* **Programación Imperativa:**  Se basa en la ejecución secuencial de instrucciones que modifican el estado del programa.  El programador especifica paso a paso cómo se debe realizar un cálculo.\n* **Programación Orientada a Objetos (POO):**  Se basa en el concepto de \"objetos\" que encapsulan datos (atributos) y comportamiento (métodos).  La POO promueve la reutilización de código, la modularidad y la abstracción.\n* **Programación Funcional:**  Se basa en el concepto de funciones matemáticas puras, que no tienen efectos secundarios (no modifican el estado del programa).  La programación funcional promueve la inmutabilidad, la recursión y la composición de funciones.\n* **Programación Declarativa:**  Se centra en *qué* se debe calcular, en lugar de *cómo*.  El programador especifica las relaciones entre los datos y el sistema se encarga de encontrar la solución.\n\n### SINTAXIS Y SEMANTICA\n\n* **Sintaxis:**  Las reglas que definen la estructura válida de un programa.  Es como la gramática de un lenguaje natural.  Si un programa tiene errores de sintaxis, el compilador o intérprete no podrá entenderlo.\n* **Semántica:**  El significado de las construcciones del lenguaje.  Define qué hace un programa cuando se ejecuta.  Un programa puede ser sintácticamente correcto pero semánticamente incorrecto (por ejemplo, realizar un cálculo incorrecto).\n\n### COMPILADORES E INTERPRETES\n\n* **Compilador:**  Un programa que traduce el código fuente de un lenguaje de programación a código máquina (o a otro lenguaje intermedio).  El código compilado se puede ejecutar directamente por la computadora.\n* **Intérprete:**  Un programa que ejecuta el código fuente directamente, línea por línea.  No se genera un archivo ejecutable separado.\n\n## INFORMACION DE INTERES\n\n***Lenguajes de Dominio Específico (DSL)***: Lenguajes diseñados para un dominio específico, como el diseño de hardware (VHDL, Verilog) o la manipulación de datos (SQL).\n\n***Metaprogramación***: La capacidad de un programa para manipular otros programas (o a sí mismo) como datos. Algunos lenguajes, como Lisp y Smalltalk, son especialmente adecuados para la metaprogramación.\n\n***Evolución de los Lenguajes***: Los lenguajes de programación están en constante evolución, adaptándose a las nuevas tecnologías y necesidades. Nuevos lenguajes surgen regularmente, y los lenguajes existentes se actualizan con nuevas características y mejoras.\n\n***La Importancia de Elegir el Lenguaje Correcto***: La elección del lenguaje de programación adecuado depende del proyecto, los requisitos de rendimiento, la experiencia del equipo y otros factores. No existe un \"mejor\" lenguaje para todos los casos.\n\n## FUENTES DE INFORMACION\n\nWikipedia: https://es.wikipedia.org/wiki/Lenguaje\\_de\\_programaci%C3%B3n\n\nFreeCodeCamp: https://www.freecodecamp.org/news/what-is-a-programming-language/\n\nGeeksforGeeks: https://www.geeksforgeeks.org/programming-languages/\n\nEste documento proporciona una introducción general a los lenguajes de programación. Para obtener información más detallada sobre un lenguaje específico, se recomienda consultar la documentación oficial del lenguaje y otros recursos especializados.\n"
  },
  {
    "slug": "/programming/languages/javascript",
    "title": "Javascript",
    "description": "Lenguaje de programación esencial para el desarrollo web, conocido por su versatilidad y capacidad para crear experiencias interactivas en navegadores.",
    "content": "JavaScript es un lenguaje de programación de alto nivel, interpretado y multiparadigma. Esencialmente, es el lenguaje que da vida a la web, permitiendo la creación de páginas interactivas y dinámicas. Aunque inicialmente se diseñó para ejecutarse en navegadores web, su versatilidad lo ha llevado a ser utilizado en una amplia gama de entornos, desde el desarrollo de aplicaciones móviles hasta la programación del lado del servidor.\n\n## HISTORIA DE JAVASCRIPT\n\nJavaScript fue creado en 1995 por Brendan Eich, un programador de Netscape. Originalmente, se llamaba Mocha, luego LiveScript, y finalmente JavaScript. Su creación fue impulsada por la necesidad de añadir interactividad a las páginas web, que en ese entonces eran estáticas. Netscape Navigator 2.0 fue el primer navegador en soportar JavaScript, y rápidamente se convirtió en un estándar de la industria.\n\nA pesar de su nombre, JavaScript no está directamente relacionado con Java. El nombre \"JavaScript\" fue una estrategia de marketing para aprovechar la popularidad de Java en ese momento.\n\n## OBJETIVOS CLAVE DE JAVASCRIPT\n\n* **Interactividad:** Permitir a los desarrolladores crear páginas web que respondan a las acciones del usuario, como clics, movimientos del ratón y pulsaciones de teclas.\n* **Dinamismo:** Modificar el contenido de una página web en tiempo real, sin necesidad de recargar la página.\n* **Validación de datos:** Verificar la información ingresada por el usuario en formularios web antes de enviarla al servidor.\n* **Desarrollo Frontend:** Construir interfaces de usuario ricas y complejas para aplicaciones web.\n* **Desarrollo Backend:** Utilizar Node.js para crear aplicaciones del lado del servidor con JavaScript.\n* **Compatibilidad:** Funcionar en una amplia variedad de navegadores y dispositivos.\n\n## INFORMACION RELEVANTE SOBRE JAVASCRIPT\n\n### CARACTERISTICAS PRINCIPALES\n\n* **Lenguaje Interpretado:** El código JavaScript se ejecuta directamente en el navegador, sin necesidad de compilación previa.\n* **Tipado Dinámico:** El tipo de una variable se determina en tiempo de ejecución, lo que facilita la escritura de código pero requiere más pruebas para evitar errores.\n* **Multiparadigma:** Soporta programación orientada a objetos, programación funcional y programación imperativa.\n* **Basado en Prototipos:** Utiliza prototipos en lugar de clases para la herencia y la creación de objetos.\n* **Manejo de Eventos:** Permite responder a eventos del usuario, como clics, movimientos del ratón y pulsaciones de teclas.\n* **Asíncrono:** Facilita la ejecución de tareas en segundo plano sin bloquear la interfaz de usuario.\n\n### ECMASCRIPT\n\nECMAScript es el estándar que define la especificación del lenguaje JavaScript. A lo largo de los años, se han publicado varias versiones de ECMAScript, cada una con nuevas características y mejoras. Las versiones más recientes, como ES6 (ECMAScript 2015) y ES7 (ECMAScript 2016), han introducido características importantes como clases, módulos, funciones de flecha y promesas.\n\n### JAVASCRIPT EN EL FRONTEND\n\nEn el desarrollo frontend, JavaScript se utiliza para manipular el Document Object Model (DOM), que representa la estructura de una página web. Esto permite a los desarrolladores modificar el contenido, el estilo y el comportamiento de una página web en respuesta a las acciones del usuario.\n\n### JAVASCRIPT EN EL BACKEND\n\nNode.js es un entorno de ejecución de JavaScript que permite a los desarrolladores utilizar JavaScript para construir aplicaciones del lado del servidor. Esto significa que puedes usar el mismo lenguaje tanto en el frontend como en el backend, lo que facilita la colaboración y el intercambio de código entre los equipos de desarrollo.\n\n### FRAMEWORKS Y LIBRERIAS DE JAVASCRIPT\n\nExisten numerosos frameworks y librerías de JavaScript que facilitan el desarrollo de aplicaciones web complejas. Algunos de los más populares incluyen:\n\n* **React:** Una librería para construir interfaces de usuario, especialmente adecuada para aplicaciones con grandes cantidades de datos y componentes reutilizables.\n* **Angular:** Un framework completo para construir aplicaciones web de una sola página (SPA).\n* **Vue.js:** Un framework progresivo para construir interfaces de usuario, conocido por su facilidad de uso y flexibilidad.\n* **jQuery:** Una librería que simplifica la manipulación del DOM y la gestión de eventos.\n\n## PROCESO DE INSTALACION\n\nJavaScript no requiere una instalación explícita para ejecutarse en un navegador web. Simplemente necesitas un navegador moderno que soporte JavaScript. Para el desarrollo del lado del servidor con Node.js, debes instalar Node.js en tu sistema.\n\n1. **Descarga Node.js:** Visita el sitio web oficial de Node.js ([https://nodejs.org/](https://nodejs.org/)) y descarga la versión adecuada para tu sistema operativo.\n2. **Instala Node.js:** Ejecuta el instalador descargado y sigue las instrucciones.\n3. **Verifica la instalación:** Abre una terminal o línea de comandos y ejecuta el comando `node -v`. Esto debería mostrar la versión de Node.js instalada.\n4. **Instala un editor de código:** Puedes utilizar cualquier editor de código para escribir código JavaScript, como Visual Studio Code, Sublime Text o Atom.\n\n## FUENTES DE INVESTIGACION\n\n* **Mozilla Developer Network (MDN):** [https://developer.mozilla.org/](https://developer.mozilla.org/)\n* **ECMAScript Specification:** [https://www.ecma-international.org/](https://www.ecma-international.org/)\n* **Node.js Official Website:** [https://nodejs.org/](https://nodejs.org/)\n* **React Official Website:** [https://reactjs.org/](https://reactjs.org/)\n* **Angular Official Website:** [https://angular.io/](https://angular.io/)\n* **Vue.js Official Website:** [https://vuejs.org/](https://vuejs.org/)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/arrays",
    "title": "Arrays en JavaScript",
    "description": "Guía completa sobre arrays en JavaScript creación, manipulación, métodos y casos de uso.",
    "content": "Los arrays son una de las estructuras de datos más fundamentales en JavaScript. Permiten almacenar colecciones ordenadas de elementos, que pueden ser de cualquier tipo de dato, incluyendo números, strings, objetos, e incluso otros arrays. Esta flexibilidad los convierte en una herramienta esencial para la manipulación y organización de datos en aplicaciones web y del lado del servidor.\n\n## OBJETIVOS CLAVE\n\n* **Comprender la sintaxis y la creación de arrays:** Aprender las diferentes formas de declarar e inicializar arrays en JavaScript.\n* **Dominar los métodos de manipulación:** Conocer y aplicar los métodos más comunes para añadir, eliminar, modificar y buscar elementos en un array.\n* **Utilizar métodos de iteración:** Aprender a iterar sobre los elementos de un array utilizando métodos como `map`, `filter`, `reduce`, y otros.\n* **Aplicar arrays en casos prácticos:** Entender cómo los arrays pueden ser utilizados para resolver problemas comunes en el desarrollo de software.\n\n## DESARROLLO DEL TEMA\n\n### CREACION DE ARRAYS\n\nEn JavaScript, un array se puede crear de varias maneras:\n\n1. **Literal:**\n\n   ```javascript\n   let miArray = []; // Array vacío\r\n   let numeros = [1, 2, 3, 4, 5]; // Array con números\r\n   let mixto = [1, \"hola\", true, {nombre: \"Juan\"}]; // Array con diferentes tipos de datos\n   ```\n2. **Constructor `Array()`:**\n\n   ```javascript\n   let miArray = new Array(); // Array vacío\r\n   let numeros = new Array(1, 2, 3, 4, 5); // Array con números\r\n   let tamaño = new Array(10); // Array con 10 elementos vacíos\n   ```\n\n### ACCESO A LOS ELEMENTOS\n\nLos elementos de un array se acceden mediante su índice, que comienza en 0.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\"];\r\nconsole.log(frutas[0]); // \"manzana\"\r\nconsole.log(frutas[1]); // \"banana\"\r\nconsole.log(frutas[2]); // \"naranja\"\n```\n\n## METODOS DE MANIPULACION\n\nJavaScript proporciona una amplia gama de métodos para manipular `arrays`. Aquí están algunos de los más comunes:\n\n### 1. push()\n\nAñade uno o más elementos al final del array.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\"];\r\nfrutas.push(\"naranja\");\r\nconsole.log(frutas); // [\"manzana\", \"banana\", \"naranja\"]\n```\n\n### 2. pop()\n\nElimina el último elemento del array y lo devuelve.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\"];\r\nlet ultimaFruta = frutas.pop();\r\nconsole.log(frutas); // [\"manzana\", \"banana\"]\r\nconsole.log(ultimaFruta); // \"naranja\"\n```\n\n### 3. shift()\n\nElimina el primer elemento del array y lo devuelve.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\"];\r\nlet primeraFruta = frutas.shift();\r\nconsole.log(frutas); // [\"banana\", \"naranja\"]\r\nconsole.log(primeraFruta); // \"manzana\"\n```\n\n### 4. unshift()\n\nAñade uno o más elementos al principio del array.\n\n```javascript\nlet frutas = [\"banana\", \"naranja\"];\r\nfrutas.unshift(\"manzana\");\r\nconsole.log(frutas); // [\"manzana\", \"banana\", \"naranja\"]\n```\n\n### 5. splice()\n\nPermite añadir, eliminar o reemplazar elementos en cualquier posición del array.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\"];\r\n// Eliminar 1 elemento desde la posición 1\r\nfrutas.splice(1, 1);\r\nconsole.log(frutas); // [\"manzana\", \"naranja\"]\r\n\r\n// Añadir \"kiwi\" en la posición 1\r\nfrutas.splice(1, 0, \"kiwi\");\r\nconsole.log(frutas); // [\"manzana\", \"kiwi\", \"naranja\"]\r\n\r\n// Reemplazar \"manzana\" con \"pera\" en la posición 0\r\nfrutas.splice(0, 1, \"pera\");\r\nconsole.log(frutas); // [\"pera\", \"kiwi\", \"naranja\"]\n```\n\n### slice()\n\nCrea una copia superficial de una porción del array.\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\", \"kiwi\"];\r\nlet porcion = frutas.slice(1, 3); // Desde el índice 1 hasta el 3 (sin incluir)\r\nconsole.log(porcion); // [\"banana\", \"naranja\"]\r\nconsole.log(frutas); // [\"manzana\", \"banana\", \"naranja\", \"kiwi\"] (el array original no se modifica)\n```\n\n## METODOS DE ITERACION\n\nLos métodos de iteración permiten realizar operaciones en cada elemento del array de manera eficiente.\n\n### 1. forEach()\n\nEjecuta una función para cada elemento del array.\n\n```javascript\nlet numeros = [1, 2, 3];\r\nnumeros.forEach(function(numero) {\r\n  console.log(numero * 2);\r\n});\r\n// 2\r\n// 4\r\n// 6\n```\n\n### 2. map()\n\nCrea un nuevo array con los resultados de aplicar una función a cada elemento del array original.\n\n```javascript\nlet numeros = [1, 2, 3];\r\nlet dobles = numeros.map(function(numero) {\r\n  return numero * 2;\r\n});\r\nconsole.log(dobles); // [2, 4, 6]\n```\n\n### 3. filter()\n\nCrea un nuevo array con todos los elementos que cumplen una condición específica.\n\n```javascript\nlet numeros = [1, 2, 3, 4, 5];\r\nlet pares = numeros.filter(function(numero) {\r\n  return numero % 2 === 0;\r\n});\r\nconsole.log(pares); // [2, 4]\n```\n\n### 4. reduce()\n\nAplica una función a un acumulador y a cada elemento del array (de izquierda a derecha) para reducirlo a un único valor.\n\n```javascript\nlet numeros = [1, 2, 3, 4];\r\nlet suma = numeros.reduce(function(acumulador, numero) {\r\n  return acumulador + numero;\r\n}, 0); // 0 es el valor inicial del acumulador\r\nconsole.log(suma); // 10\n```\n\n### 5. find()\n\nDevuelve el valor del primer elemento en el array que satisfaga la función de prueba proporcionada. En caso contrario, devuelve undefined.\n\n```javascript\nconst numeros = [5, 12, 8, 130, 44];\r\n\r\nconst encontrado = numeros.find(elemento => elemento > 10);\r\n\r\nconsole.log(encontrado); // Output: 12\n```\n\n### 6. findIndex()\n\nDevuelve el índice del primer elemento en el array que satisfaga la función de prueba proporcionada. En caso contrario, devuelve -1.\n\n```javascript\nconst numeros = [5, 12, 8, 130, 44];\r\n\r\nconst esGrande = (elemento) => elemento > 13;\r\n\r\nconsole.log(numeros.findIndex(esGrande)); // Output: 3\n```\n\n## EJEMPLOS DE IMPLEMENTACION\n\n1. Calcular el promedio de una lista de números\n\n```javascript\nfunction calcularPromedio(numeros) {\r\n  let suma = numeros.reduce((acumulador, numero) => acumulador + numero, 0);\r\n  return suma / numeros.length;\r\n}\r\n\r\nlet notas = [85, 90, 78, 92, 88];\r\nlet promedio = calcularPromedio(notas);\r\nconsole.log(\"El promedio es:\", promedio); // El promedio es: 86.6\n```\n\n2. Filtrar productos por precio\n\n```javascript\nlet productos = [\r\n  { nombre: \"Camiseta\", precio: 25 },\r\n  { nombre: \"Pantalón\", precio: 50 },\r\n  { nombre: \"Zapatos\", precio: 80 },\r\n  { nombre: \"Gorra\", precio: 15 }\r\n];\r\n\r\nfunction filtrarPorPrecio(productos, precioMaximo) {\r\n  return productos.filter(producto => producto.precio <= precioMaximo);\r\n}\r\n\r\nlet productosBaratos = filtrarPorPrecio(productos, 40);\r\nconsole.log(\"Productos baratos:\", productosBaratos);\r\n// Productos baratos:\r\n// [\r\n//   { nombre: \"Camiseta\", precio: 25 },\r\n//   { nombre: \"Gorra\", precio: 15 }\r\n// ]\n```\n\n## FUENTES DEL DOCUMENTO\n\n* [**MDN Web Docs**: Array](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n* [**W3Schools**: JavaScript Arrays](https://www.w3schools.com/js/js_arrays.asp)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/control-structures",
    "title": "Estructuras de Control en JavaScript",
    "description": "Guía detallada sobre las estructuras de control en JavaScript condicionales (if, else, switch) y bucles (for, while, do...while).",
    "content": "Las estructuras de control son componentes fundamentales en cualquier lenguaje de programación, incluyendo JavaScript. Permiten a los desarrolladores controlar el flujo de ejecución de un programa, tomando decisiones y repitiendo bloques de código según ciertas condiciones. En JavaScript, las estructuras de control se dividen principalmente en dos categorías: condicionales y bucles.\n\n## OBJETIVOS CLAVE\n\n* **Comprender los tipos de estructuras de control:** Identificar y diferenciar las estructuras condicionales (if, else, switch) y los bucles (for, while, do...while).\n* **Aplicar condicionales para la toma de decisiones:** Utilizar `if`, `else if` y `else` para ejecutar diferentes bloques de código basados en condiciones específicas.\n* **Implementar bucles para la repetición de código:** Utilizar `for`, `while` y `do...while` para repetir la ejecución de un bloque de código un número determinado de veces o hasta que se cumpla una condición.\n* **Controlar el flujo de bucles:** Utilizar `break` y `continue` para modificar el comportamiento de los bucles.\n* **Optimizar el uso de estructuras de control:** Elegir la estructura de control más adecuada para cada situación, mejorando la legibilidad y eficiencia del código.\n\n## CONDICIONALES\n\nLas estructuras condicionales permiten ejecutar diferentes bloques de código dependiendo de si una condición es verdadera o falsa.\n\n### IF, ELSE IF Y ELSE\n\nLa estructura `if` es la más básica de las condicionales. Permite ejecutar un bloque de código si una condición es verdadera.\n\n```javascript\nlet edad = 18;\r\n\r\nif (edad >= 18) {\r\n  console.log(\"Eres mayor de edad.\");\r\n}\n```\n\nSi la condición dentro del paréntesis es verdadera, el código dentro de las llaves se ejecuta. Si es falsa, el código se omite.\n\nLa estructura `else` se utiliza para ejecutar un bloque de código si la condición del `if` es falsa.\n\n```javascript\nlet edad = 15;\r\n\r\nif (edad >= 18) {\r\n  console.log(\"Eres mayor de edad.\");\r\n} else {\r\n  console.log(\"Eres menor de edad.\");\r\n}\n```\n\nLa estructura `else if` permite encadenar múltiples condiciones. Se evalúa cada condición en orden, y si una es verdadera, se ejecuta el bloque de código correspondiente.\n\n```javascript\nlet nota = 75;\r\n\r\nif (nota >= 90) {\r\n  console.log(\"Sobresaliente\");\r\n} else if (nota >= 70) {\r\n  console.log(\"Notable\");\r\n} else if (nota >= 50) {\r\n  console.log(\"Aprobado\");\r\n} else {\r\n  console.log(\"Suspenso\");\r\n}\n```\n\n## SWITCH\n\nLa estructura `switch` es útil cuando se tienen múltiples casos posibles para una variable. Permite ejecutar diferentes bloques de código basados en el valor de una expresión.\n\n```javascript\nlet dia = \"lunes\";\r\n\r\nswitch (dia) {\r\n  case \"lunes\":\r\n    console.log(\"Es el primer día de la semana.\");\r\n    break;\r\n  case \"viernes\":\r\n    console.log(\"Es viernes, ¡el fin de semana está cerca!\");\r\n    break;\r\n  default:\r\n    console.log(\"Es otro día de la semana.\");\r\n}\n```\n\nCada `case` compara el valor de la expresión con un valor específico. Si hay una coincidencia, se ejecuta el código correspondiente. La palabra clave `break` es importante para evitar que se ejecuten los casos siguientes. El `default` se ejecuta si ninguno de los casos coincide.\n\n## BUCLES\n\nLos bucles permiten repetir un bloque de código múltiples veces. JavaScript ofrece varios tipos de bucles, cada uno adecuado para diferentes situaciones.\n\n### FOR\n\nEl bucle `for` es ideal cuando se conoce el número de iteraciones que se deben realizar.\n\n```javascript\nfor (let i = 0; i < 5; i++) {\r\n  console.log(\"Iteración número \" + i);\r\n}\n```\n\nEl bucle `for` consta de tres partes:\n\n1. **Inicialización**: Se ejecuta una vez al principio del bucle (ej: `let i = 0`).\n\n2. **Condición**: Se evalúa antes de cada iteración. Si es verdadera, el bucle continúa; si es falsa, el bucle termina (ej: `i < 5`).\n\n3. **Incremento/Decremento**: Se ejecuta después de cada iteración (ej: `i++`).\n\n### WHILE\n\nEl bucle `while` se utiliza cuando se necesita repetir un bloque de código mientras una condición sea verdadera.\n\n```javascript\nlet contador = 0;\r\n\r\nwhile (contador < 5) {\r\n  console.log(\"Contador: \" + contador);\r\n  contador++;\r\n}\n```\n\nEl bucle `while` evalúa la condición antes de cada iteración. Si la condición es verdadera, el código dentro del bucle se ejecuta. Es importante asegurarse de que la condición eventualmente se vuelva falsa para evitar un bucle infinito.\n\n### DO...WHILE\n\nEl bucle `do...while` es similar al `while`, pero garantiza que el bloque de código se ejecute al menos una vez.\n\n```javascript\nlet contador = 0;\r\n\r\ndo {\r\n  console.log(\"Contador: \" + contador);\r\n  contador++;\r\n} while (contador < 5);\n```\n\nEl bucle `do...while` ejecuta el bloque de código primero y luego evalúa la condición. Si la condición es verdadera, el bucle se repite.\n\n### BREAK Y CONTINUE\n\nLas sentencias `break` y continue permiten controlar el flujo de los bucles.\n\n* **Break**: Termina la ejecución del bucle actual.\n\n  ```javascript\n  for (let i = 0; i < 10; i++) {\r\n  if (i === 5) {\r\n      break; // Sale del bucle cuando i es igual a 5\r\n  }\r\n  console.log(\"Iteración: \" + i);\r\n  }\n  ```\n\n* **Continue**: Salta la iteración actual y continúa con la siguiente.\n\n  ```javascript\n  for (let i = 0; i < 10; i++) {\r\n  if (i % 2 === 0) {\r\n      continue; // Salta las iteraciones donde i es par\r\n  }\r\n  console.log(\"Iteración: \" + i);\r\n  }\n  ```\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO 1: DETERMINAR SI UN NUMERO ES PAR O IMPAR\n\n```javascript\nfunction esParOImpar(numero) {\r\n  if (numero % 2 === 0) {\r\n    return \"El número es par\";\r\n  } else {\r\n    return \"El número es impar\";\r\n  }\r\n}\r\n\r\nconsole.log(esParOImpar(4)); // Imprime: El número es par\r\nconsole.log(esParOImpar(7)); // Imprime: El número es impar\n```\n\n### EJEMPLO 2: ITERAR SOBRE UN ARRAY\n\n```javascript\nlet frutas = [\"manzana\", \"banana\", \"naranja\"];\r\n\r\nfor (let i = 0; i < frutas.length; i++) {\r\n  console.log(\"Fruta: \" + frutas[i]);\r\n}\n```\n\n### EJEMPLO 3: SIMULAR UN JUEGO DE ADIVINAR UN NUMERO\n\n```javascript\nlet numeroSecreto = Math.floor(Math.random() * 10) + 1;\r\nlet intento;\r\nlet intentosRealizados = 0;\r\n\r\ndo {\r\n  intento = parseInt(prompt(\"Adivina el número (entre 1 y 10):\"));\r\n  intentosRealizados++;\r\n\r\n  if (intento === numeroSecreto) {\r\n    alert(\"¡Felicidades! Adivinaste el número en \" + intentosRealizados + \" intentos.\");\r\n  } else if (intento < numeroSecreto) {\r\n    alert(\"El número es mayor. Intenta de nuevo.\");\r\n  } else {\r\n    alert(\"El número es menor. Intenta de nuevo.\");\r\n  }\r\n} while (intento !== numeroSecreto);\n```\n\n## FUENTES DEL DOCUMENTO\n\n* [MDN Web Docs: Control flow and error handling](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling)\n\n* [W3Schools: JavaScript if...else Statement](https://www.w3schools.com/js/js_if_else.asp)\n\n* [W3Schools: JavaScript Switch Statement](https://www.w3schools.com/js/js_switch.asp)\n\n* [W3Schools: JavaScript For Loop](https://www.w3schools.com/js/js_loop_for.asp)\n\n* [W3Schools: JavaScript While Loop](https://www.w3schools.com/js/js_loop_while.asp)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/functions",
    "title": "Funciones de Javascript",
    "description": "Explicación detallada de las funciones en JavaScript, incluyendo su sintaxis, tipos, uso y mejores prácticas.",
    "content": "Las funciones son uno de los conceptos fundamentales en JavaScript. Permiten encapsular bloques de código para que puedan ser reutilizados y ejecutados múltiples veces. Una función es un conjunto de instrucciones que realiza una tarea específica.\n\n## OBJETIVOS CLAVE\n\n* Entender la sintaxis y los diferentes tipos de funciones en JavaScript.\n* Aprender a definir y llamar funciones.\n* Comprender el concepto de parámetros y argumentos.\n* Explorar el uso de la declaración de retorno.\n* Entender el scope y las closures en el contexto de las funciones.\n* Familiarizarse con las arrow functions (funciones flecha).\n\n## SINTAXIS BASICA\n\nUna función en JavaScript se define utilizando la palabra clave `function`, seguida de un nombre (opcional), una lista de parámetros entre paréntesis `()` y un bloque de código delimitado por llaves `{}`.\n\n```javascript\nfunction nombreDeLaFuncion(parametro1, parametro2) {\r\n  // Bloque de código a ejecutar\r\n  return valor; // Opcional\r\n}\n```\n\n## TIPOS DE FUNCIONES\n\nJavaScript ofrece varios tipos de funciones, cada uno con sus propias características y casos de uso.\n\n### 1. DECLARACION DE FUNCION (FUNCTION DECLARATION)\n\nLas declaraciones de función son las más comunes y se definen utilizando la palabra clave `function`.\n\n```javascript\nfunction sumar(a, b) {\r\n  return a + b;\r\n}\r\n\r\nconsole.log(sumar(5, 3)); // Output: 8\n```\n\nLas declaraciones de función son hoisted, lo que significa que pueden ser llamadas antes de que aparezcan en el código.\n\n### 2. EXPRESION DE FUNCION (FUNCTION EXPRESSION)\n\nLas expresiones de función se definen asignando una función a una variable.\n\n```javascript\nconst multiplicar = function(a, b) {\r\n  return a * b;\r\n};\r\n\r\nconsole.log(multiplicar(5, 3)); // Output: 15\n```\n\nA diferencia de las declaraciones de función, las expresiones de función no son hoisted.\n\n### 3. FUNCIONES ANONIMAS\n\nUna función anónima es una función que no tiene nombre. Se utilizan comúnmente en expresiones de función y como callbacks.\n\n```javascript\nsetTimeout(function() {\r\n  console.log(\"Esta función se ejecuta después de un tiempo.\");\r\n}, 1000);\n```\n\n### 4. ARROW FUNCTIONS (FUNCIONES FLECHA)\n\nLas `arrow` functions son una forma más concisa de escribir funciones, introducidas en ES6.\n\n```javascript\nconst dividir = (a, b) => a / b;\r\n\r\nconsole.log(dividir(15, 3)); // Output: 5\n```\n\nLas `arrow` functions tienen algunas diferencias importantes con las funciones tradicionales, como la ausencia de this propio y la imposibilidad de ser utilizadas como constructores.\n\n## PARAMETROS Y ARGUMENTOS\n\nLos parámetros son las variables listadas en la definición de la función. Los argumentos son los valores que se pasan a la función cuando se llama.\n\n```javascript\nfunction saludar(nombre) { // 'nombre' es un parámetro\r\n  console.log(\"Hola, \" + nombre + \"!\");\r\n}\r\n\r\nsaludar(\"Juan\"); // \"Juan\" es un argumento\n```\n\n### PARAMETROS POR DEFECTO\n\nEn ES6, se pueden definir valores por defecto para los parámetros.\n\n```javascript\nfunction saludar(nombre = \"Invitado\") {\r\n  console.log(\"Hola, \" + nombre + \"!\");\r\n}\r\n\r\nsaludar(); // Output: Hola, Invitado!\r\nsaludar(\"Ana\"); // Output: Hola, Ana!\n```\n\n### REST PARAMETERS\n\nLos `rest parameters` permiten que una función acepte un número indefinido de argumentos como un `array`.\n\n```javascript\nfunction sumarTodos(...numeros) {\r\n  let total = 0;\r\n  for (let numero of numeros) {\r\n    total += numero;\r\n  }\r\n  return total;\r\n}\r\n\r\nconsole.log(sumarTodos(1, 2, 3, 4, 5)); // Output: 15\n```\n\n## LA DECLARACION DE RETORNO (RETURN STATEMENT)\n\nLa declaración `return` se utiliza para especificar el valor que una función debe devolver. Si una función no tiene una declaración `return`, devuelve `undefined` por defecto.\n\n```javascript\nfunction multiplicar(a, b) {\r\n  return a * b;\r\n}\r\n\r\nlet resultado = multiplicar(4, 6);\r\nconsole.log(resultado); // Output: 24\n```\n\n## SCOPE\n\nEl `scope` se refiere a la visibilidad de las variables dentro de una función. JavaScript tiene `scope léxico`, lo que significa que el `scope` de una variable se determina por su posición en el código fuente.\n\n### SCOPE GLOBAL\n\nLas variables declaradas fuera de cualquier función tienen `scope global` y son accesibles desde cualquier parte del código.\n\n```javascript\nlet variableGlobal = \"Soy global\";\r\n\r\nfunction mostrarVariable() {\r\n  console.log(variableGlobal);\r\n}\r\n\r\nmostrarVariable(); // Output: Soy global\n```\n\n### SCOPE LOCAL (FUNCTION SCOPE)\n\nLas variables declaradas dentro de una función tienen `scope local` y solo son accesibles dentro de esa función.\n\n```javascript\nfunction miFuncion() {\r\n  let variableLocal = \"Soy local\";\r\n  console.log(variableLocal);\r\n}\r\n\r\nmiFuncion(); // Output: Soy local\r\nconsole.log(variableLocal); // Error: variableLocal is not defined\n```\n\n### BLOCK SCOPE (LET Y CONST)\n\nLas variables declaradas con `let` y `const` tienen `block scope`, lo que significa que solo son accesibles dentro del bloque en el que se definen.\n\n```javascript\nfunction ejemploBlockScope() {\r\n  if (true) {\r\n    let x = 10;\r\n    const y = 20;\r\n    var z = 30;\r\n  }\r\n  console.log(z); // Output: 30\r\n  console.log(x); // Error: x is not defined\r\n  console.log(y); // Error: y is not defined\r\n}\r\n\r\nejemploBlockScope();\n```\n\n## CLOSURES\n\nUn `closure` es una función que tiene acceso a las variables de su `scope léxico`, incluso cuando se ejecuta fuera de ese `scope`.\n\n```javascript\nfunction crearContador() {\r\n  let contador = 0;\r\n\r\n  function incrementar() {\r\n    contador++;\r\n    console.log(contador);\r\n  }\r\n\r\n  return incrementar;\r\n}\r\n\r\nconst miContador = crearContador();\r\nmiContador(); // Output: 1\r\nmiContador(); // Output: 2\n```\n\nEn este ejemplo, la función incrementar tiene acceso a la variable contador de la función `crearContador`, incluso después de que `crearContador` haya terminado de ejecutarse.\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO 1: CALCULADORA BASICA\n\n```javascript\nfunction calculadora(operacion, a, b) {\r\n  switch (operacion) {\r\n    case 'sumar':\r\n      return a + b;\r\n    case 'restar':\r\n      return a - b;\r\n    case 'multiplicar':\r\n      return a * b;\r\n    case 'dividir':\r\n      return a / b;\r\n    default:\r\n      return \"Operación no válida\";\r\n  }\r\n}\r\n\r\nconsole.log(calculadora('sumar', 5, 3)); // Output: 8\r\nconsole.log(calculadora('dividir', 10, 2)); // Output: 5\r\nconsole.log(calculadora('potencia', 2, 3)); // Output: Operación no válida\n```\n\n### EJEMPLO 2: VALIDACION DE EMAIL\n\n```javascript\nfunction validarEmail(email) {\r\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return regex.test(email);\r\n}\r\n\r\nconsole.log(validarEmail(\"test@example.com\")); // Output: true\r\nconsole.log(validarEmail(\"invalid-email\")); // Output: false\n```\n\n### EJEMPLO 3: FUNCION DE ORDEN SUPERIOR (HIGHER-ORDER FUNCTION)\n\nUna función de orden superior es una función que recibe otras funciones como argumentos o devuelve una función como resultado.\n\n```javascript\nfunction aplicarOperacion(arr, operacion) {\r\n  let resultado = [];\r\n  for (let elemento of arr) {\r\n    resultado.push(operacion(elemento));\r\n  }\r\n  return resultado;\r\n}\r\n\r\nfunction cuadrado(x) {\r\n  return x * x;\r\n}\r\n\r\nconst numeros = [1, 2, 3, 4, 5];\r\nconst cuadrados = aplicarOperacion(numeros, cuadrado);\r\nconsole.log(cuadrados); // Output: [1, 4, 9, 16, 25]\n```\n\n## FUENTES DEL DOCUMENTO\n\n* [**MDN Web Docs**: Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions)\n\n* [**W3Schools**: JavaScript Functions](https://www.w3schools.com/js/js_functions.asp)\n\n* [**JavaScript.info**: Functions](https://javascript.info/function-basics)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals",
    "title": "Fundamentos de Javascript",
    "description": "Exploración de los conceptos básicos de Javascript, incluyendo variables, tipos de datos, operadores, estructuras de control y funciones.",
    "content": "# FUNDAMENTOS DE JAVASCRIPT\n\nJavascript es un lenguaje de programación esencial para el desarrollo web moderno. Permite añadir interactividad y dinamismo a las páginas web, creando experiencias de usuario ricas y atractivas. Comprender los fundamentos de Javascript es crucial para cualquier desarrollador web, ya que sienta las bases para construir aplicaciones web complejas y eficientes.\n\n## OBJETIVOS CLAVE\n\n* Comprender los conceptos básicos de Javascript.\n* Aprender a declarar y utilizar variables.\n* Conocer los diferentes tipos de datos en Javascript.\n* Utilizar operadores para realizar cálculos y comparaciones.\n* Implementar estructuras de control para tomar decisiones y repetir acciones.\n* Definir y llamar funciones para organizar y reutilizar el código.\n\n## VARIABLES\n\nLas variables son contenedores que almacenan datos. En Javascript, se declaran utilizando las palabras clave `var`, `let` o `const`.\n\n* **`var`**: Declara una variable con alcance de función o global.\n* **`let`**: Declara una variable con alcance de bloque.\n* **`const`**: Declara una constante, cuyo valor no puede ser reasignado.\n\n```javascript\nvar nombre = \"Juan\";    // Variable con alcance global o de función\r\nlet edad = 30;          // Variable con alcance de bloque\r\nconst PI = 3.1416;      // Constante\n```\n\n## TIPOS DE DATOS\n\nJavascript tiene varios tipos de datos primitivos:\n\n* **Number**: Representa valores numéricos, tanto enteros como decimales.\n\n* **String**: Representa cadenas de texto.\n\n* **Boolean**: Representa valores lógicos (verdadero o falso).\n\n* **Null**: Representa la ausencia intencional de valor.\n\n* **Undefined**: Representa una variable que no ha sido inicializada.\n\n* **Symbol**: Representa un identificador único.\n\n* **BigInt**: Representa enteros de precisión arbitraria.\n\nAdemás de los tipos de datos primitivos, Javascript también tiene tipos de datos complejos, como:\n\n* **Object**: Representa una colección de propiedades.\n\n* **Array**: Representa una lista ordenada de valores.\n\n```javascript\nlet numero = 10;        // Tipo Number\r\nlet texto = \"Hola\";     // Tipo String\r\nlet esVerdadero = true; // Tipo Boolean\r\nlet nulo = null;        // Tipo Null\r\nlet indefinido;         // Tipo Undefined\r\n\r\nlet persona = {         // Tipo Object\r\n  nombre: \"Juan\",\r\n  edad: 30\r\n};\r\n\r\nlet numeros = [1, 2, 3]; // Tipo Array\n```\n\n## OPERADORES\n\n* Los operadores se utilizan para realizar cálculos, comparaciones y otras operaciones en Javascript.\n\n* Operadores aritméticos: `+`, `-`, `*`, `/`, `%` (módulo), `**` (exponenciación).\n\n* Operadores de asignación: `=`, `+=`, `-=`, `*=`, `/=`, `%=`.\n\n* Operadores de comparación: `==` (igual), `!=` (no igual), `===` (igual estricto), `!==` (no igual estricto), `>`, `<`, `>=`, `<=`.\n\n* Operadores lógicos: `&&` (AND), `||` (OR), `!` (NOT).\n\n```javascript\nlet a = 10;\r\nlet b = 5;\r\n\r\nconsole.log(a + b); // 15\r\nconsole.log(a == b); // false\r\nconsole.log(a > b && a < 20); // true\n```\n\n## ESTRUCTURAS DE CONTROL\n\nLas estructuras de control permiten tomar decisiones y repetir acciones en Javascript.\n\n* `if...else`: Ejecuta un bloque de código si una condición es verdadera, y otro bloque si es falsa.\n\n* `switch`: Ejecuta diferentes bloques de código según el valor de una expresión.\n\n* `for`: Repite un bloque de código un número determinado de veces.\n\n* `while`: Repite un bloque de código mientras una condición sea verdadera.\n\n* `do...while`: Repite un bloque de código al menos una vez, y luego mientras una condición sea verdadera.\n\n```javascript\nlet edad = 18;\r\n\r\nif (edad >= 18) {\r\n  console.log(\"Es mayor de edad\");\r\n} else {\r\n  console.log(\"Es menor de edad\");\r\n}\r\n\r\nfor (let i = 0; i < 5; i++) {\r\n  console.log(i);\r\n}\n```\n\n## FUNCIONES\n\nLas funciones son bloques de código que se pueden llamar para realizar una tarea específica. Se definen utilizando la palabra clave function.\n\n```javascript\nfunction saludar(nombre) {\r\n  console.log(\"Hola, \" + nombre + \"!\");\r\n}\r\n\r\nsaludar(\"Juan\"); // Llama a la función saludar\n```\n\nLas funciones pueden recibir parámetros y devolver valores.\n\n```javascript\nfunction sumar(a, b) {\r\n  return a + b;\r\n}\r\n\r\nlet resultado = sumar(5, 3);\r\nconsole.log(resultado); // 8\n```\n\n## FUENTES\n\n* MDN Web Docs: https://developer.mozilla.org/es/docs/Web/JavaScript\n\n* W3Schools: https://www.w3schools.com/js/default.asp\n\n* freeCodeCamp: https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/objects",
    "title": "Objetos de JavaScript",
    "description": "Exploración profunda de los objetos en JavaScript, sus propiedades, métodos y cómo utilizarlos eficazmente.",
    "content": "Los objetos son una estructura fundamental en JavaScript. Permiten agrupar datos relacionados y funcionalidades en una sola unidad. En esencia, un objeto es una colección de pares clave-valor, donde las claves son cadenas (o símbolos) y los valores pueden ser cualquier tipo de dato, incluyendo otros objetos, funciones, arrays, o tipos primitivos.\n\n## OBJETIVOS CLAVE\n\n* **Comprender la sintaxis y la creación de objetos:**  Aprender a definir objetos utilizando la notación literal y el constructor `Object`.\n* **Acceder y modificar propiedades:**  Dominar las diferentes formas de acceder y modificar las propiedades de un objeto.\n* **Entender los métodos de un objeto:**  Saber cómo definir y utilizar funciones dentro de un objeto.\n* **Explorar el concepto de `this`:**  Comprender cómo el valor de `this` cambia según el contexto de ejecución.\n* **Introducción a los prototipos:**  Entender cómo funciona la herencia basada en prototipos en JavaScript.\n\n## CREACION DE OBJETOS\n\nHay varias maneras de crear objetos en JavaScript:\n\n### NOTACION LITERAL\n\nEsta es la forma más común y sencilla de crear un objeto. Se define un objeto utilizando llaves `{}` y se especifican los pares clave-valor dentro de ellas.\n\n```javascript\nconst persona = {\r\n  nombre: \"Juan\",\r\n  apellido: \"Perez\",\r\n  edad: 30,\r\n  direccion: {\r\n    calle: \"Calle Falsa 123\",\r\n    ciudad: \"Springfield\"\r\n  }\r\n};\r\n\r\nconsole.log(persona.nombre); // Output: Juan\r\nconsole.log(persona.direccion.ciudad); // Output: Springfield\n```\n\n### CONSTRUCTOR OBJECT\n\nTambién se puede crear un objeto utilizando el constructor `Object`. Aunque es menos común que la notación literal, es útil en ciertos casos.\n\n```javascript\nconst persona = new Object();\r\npersona.nombre = \"Maria\";\r\npersona.apellido = \"Gomez\";\r\npersona.edad = 25;\r\n\r\nconsole.log(persona.nombre); // Output: Maria\n```\n\n### FUNCIONES CONSTRUCTORAS\n\nLas funciones constructoras son una forma de crear objetos con una estructura predefinida. Se utilizan con la palabra clave `new`.\n\n```javascript\nfunction Persona(nombre, apellido, edad) {\r\n  this.nombre = nombre;\r\n  this.apellido = apellido;\r\n  this.edad = edad;\r\n  this.saludar = function() {\r\n    console.log(`Hola, mi nombre es ${this.nombre} ${this.apellido}`);\r\n  }\r\n}\r\n\r\nconst persona1 = new Persona(\"Carlos\", \"Rodriguez\", 40);\r\npersona1.saludar(); // Output: Hola, mi nombre es Carlos Rodriguez\n```\n\n## CLASES (ECMASCRIPT 2015)\n\nLas clases en JavaScript son una forma más moderna y legible de crear objetos, aunque internamente siguen utilizando prototipos.\n\n```javascript\nclass Persona {\r\n  constructor(nombre, apellido, edad) {\r\n    this.nombre = nombre;\r\n    this.apellido = apellido;\r\n    this.edad = edad;\r\n  }\r\n\r\n  saludar() {\r\n    console.log(`Hola, mi nombre es ${this.nombre} ${this.apellido}`);\r\n  }\r\n}\r\n\r\nconst persona1 = new Persona(\"Laura\", \"Martinez\", 35);\r\npersona1.saludar(); // Output: Hola, mi nombre es Laura Martinez\n```\n\n## ACCESO Y MODIFICACION DE PROPIEDADES\n\nHay dos formas principales de acceder a las propiedades de un objeto:\n\n### NOTACION DE PUNTO\n\nEs la forma más común y legible. Se utiliza un punto (`.`) seguido del nombre de la propiedad.\n\n```javascript\nconst persona = {\r\n  nombre: \"Juan\",\r\n  apellido: \"Perez\"\r\n};\r\n\r\nconsole.log(persona.nombre); // Output: Juan\r\n\r\npersona.edad = 30; // Agrega una nueva propiedad\r\nconsole.log(persona.edad); // Output: 30\r\n\r\npersona.nombre = \"Ricardo\"; // Modifica una propiedad existente\r\nconsole.log(persona.nombre); // Output: Ricardo\n```\n\n### NOTACION DE CORCHETES\n\nSe utiliza corchetes (`[]`) y una cadena que representa el nombre de la propiedad. Es útil cuando el nombre de la propiedad está almacenado en una variable o cuando el nombre de la propiedad no es un identificador válido (por ejemplo, contiene espacios o caracteres especiales).\n\n```javascript\nconst persona = {\r\n  nombre: \"Juan\",\r\n  apellido: \"Perez\"\r\n};\r\n\r\nconsole.log(persona[\"nombre\"]); // Output: Juan\r\n\r\nconst propiedad = \"apellido\";\r\nconsole.log(persona[propiedad]); // Output: Perez\r\n\r\npersona[\"edad\"] = 30; // Agrega una nueva propiedad\r\nconsole.log(persona[\"edad\"]); // Output: 30\n```\n\n## METODOS DE UN OBJETO\n\nUn método es una función que es propiedad de un objeto. Se define como cualquier otra propiedad, pero su valor es una función.\n\n```javascript\nconst persona = {\r\n  nombre: \"Juan\",\r\n  apellido: \"Perez\",\r\n  saludar: function() {\r\n    console.log(`Hola, mi nombre es ${this.nombre} ${this.apellido}`);\r\n  },\r\n  nombreCompleto: function() {\r\n    return this.nombre + \" \" + this.apellido;\r\n  }\r\n};\r\n\r\npersona.saludar(); // Output: Hola, mi nombre es Juan Perez\r\nconsole.log(persona.nombreCompleto()); // Output: Juan Perez\n```\n\n## LA PALABRA CLAVE this\n\nEl valor de `this` depende del contexto en el que se está ejecutando el código. Dentro de un método de un objeto, `this` se refiere al objeto en sí.\n\n```javascript\nconst persona = {\r\n  nombre: \"Juan\",\r\n  apellido: \"Perez\",\r\n  saludar: function() {\r\n    console.log(`Hola, mi nombre es ${this.nombre} ${this.apellido}`);\r\n  }\r\n};\r\n\r\npersona.saludar(); // Output: Hola, mi nombre es Juan Perez\n```\n\nEn este ejemplo, `this.nombre` y `this.apellido` se refieren a las propiedades nombre y apellido del objeto persona.\n\nEs importante tener en cuenta que el valor de this puede cambiar si la función se llama de una manera diferente. Por ejemplo, si la función se llama utilizando `call` o `apply`, se puede especificar explícitamente el valor de `this`.\n\n## PROTOTIPOS\n\nEn JavaScript, los objetos heredan propiedades y métodos de un prototipo. Cada objeto tiene un prototipo asociado, y cuando se intenta acceder a una propiedad que no existe en el objeto, JavaScript busca en el prototipo del objeto. Si la propiedad no se encuentra en el prototipo, JavaScript busca en el prototipo del prototipo, y así sucesivamente hasta llegar al prototipo final, que es `null`.\n\n```javascript\nfunction Persona(nombre, apellido) {\r\n  this.nombre = nombre;\r\n  this.apellido = apellido;\r\n}\r\n\r\nPersona.prototype.saludar = function() {\r\n  console.log(`Hola, mi nombre es ${this.nombre} ${this.apellido}`);\r\n};\r\n\r\nconst persona1 = new Persona(\"Carlos\", \"Rodriguez\");\r\npersona1.saludar(); // Output: Hola, mi nombre es Carlos Rodriguez\n```\n\nEn este ejemplo, el método `saludar` se define en el prototipo de la función `Persona`. Todos los objetos creados con la función `Persona` heredarán el método `saludar`.\n\n## HERENCIA\n\nJavaScript utiliza herencia basada en prototipos. Esto significa que los objetos pueden heredar propiedades y métodos de otros objetos. La herencia se implementa utilizando la cadena de prototipos.\n\n```javascript\nfunction Empleado(nombre, apellido, salario) {\r\n  Persona.call(this, nombre, apellido); // Llama al constructor de Persona\r\n  this.salario = salario;\r\n}\r\n\r\nEmpleado.prototype = Object.create(Persona.prototype); // Establece el prototipo de Empleado\r\nEmpleado.prototype.constructor = Empleado; // Restablece el constructor\r\n\r\nEmpleado.prototype.aumentarSalario = function(porcentaje) {\r\n  this.salario *= (1 + porcentaje / 100);\r\n};\r\n\r\nconst empleado1 = new Empleado(\"Ana\", \"Lopez\", 50000);\r\nempleado1.saludar(); // Output: Hola, mi nombre es Ana Lopez\r\nconsole.log(empleado1.salario); // Output: 50000\r\nempleado1.aumentarSalario(10);\r\nconsole.log(empleado1.salario); // Output: 55000\n```\n\nEn este ejemplo, la función `Empleado` hereda de la función `Persona`. Se utiliza `Persona.call(this, nombre, apellido)` para llamar al constructor de `Persona` y establecer las propiedades `nombre` y `apellido`. Luego, se establece el prototipo de `Empleado` para que herede del prototipo de `Persona`. Finalmente, se define un nuevo método `aumentarSalario` en el prototipo de Empleado.\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### CREACION DE UN OBJETO LITERAL\n\n```javascript\nconst libro = {\r\n  titulo: \"El Señor de los Anillos\",\r\n  autor: \"J.R.R. Tolkien\",\r\n  anioPublicacion: 1954,\r\n  genero: \"Fantasia\",\r\n  mostrarInformacion: function() {\r\n    console.log(`Titulo: ${this.titulo}, Autor: ${this.autor}, Año: ${this.anioPublicacion}, Genero: ${this.genero}`);\r\n  }\r\n};\r\n\r\nlibro.mostrarInformacion(); // Output: Titulo: El Señor de los Anillos, Autor: J.R.R. Tolkien, Año: 1954, Genero: Fantasia\n```\n\n### CREACION DE UN OBJETO CON UNA CLASE\n\n```javascript\nclass Coche {\r\n  constructor(marca, modelo, anio) {\r\n    this.marca = marca;\r\n    this.modelo = modelo;\r\n    this.anio = anio;\r\n    this.velocidad = 0;\r\n  }\r\n\r\n  acelerar(incremento) {\r\n    this.velocidad += incremento;\r\n    console.log(`Acelerando. Velocidad actual: ${this.velocidad} km/h`);\r\n  }\r\n\r\n  frenar(decremento) {\r\n    this.velocidad -= decremento;\r\n    if (this.velocidad < 0) {\r\n      this.velocidad = 0;\r\n    }\r\n    console.log(`Frenando. Velocidad actual: ${this.velocidad} km/h`);\r\n  }\r\n\r\n  mostrarInformacion() {\r\n    console.log(`Marca: ${this.marca}, Modelo: ${this.modelo}, Año: ${this.anio}`);\r\n  }\r\n}\r\n\r\nconst miCoche = new Coche(\"Toyota\", \"Corolla\", 2020);\r\nmiCoche.mostrarInformacion(); // Output: Marca: Toyota, Modelo: Corolla, Año: 2020\r\nmiCoche.acelerar(50); // Output: Acelerando. Velocidad actual: 50 km/h\r\nmiCoche.frenar(20); // Output: Frenando. Velocidad actual: 30 km/h\n```\n\n## FUENTES DEL DOCUMENTO\n\n* [**MDN Web Docs**: Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)\n\n* [**You Don't Know JS**: this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20&%20object%20prototypes/README.md)\n\n* [**Eloquent JavaScript**: Objects](https://eloquentjavascript.net/06_object.html)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/operators",
    "title": "Operadores de Javascript",
    "description": "Exploración detallada de los operadores en JavaScript, incluyendo tipos, precedencia y ejemplos de uso.",
    "content": "Los operadores en JavaScript son símbolos especiales que realizan operaciones sobre uno o más operandos (valores o variables). Estos operadores permiten manipular datos, realizar cálculos, tomar decisiones y controlar el flujo de un programa. Comprender los diferentes tipos de operadores y cómo funcionan es fundamental para escribir código JavaScript eficiente y correcto.\n\n## OBJETIVOS CLAVE\n\n* **Entender los Tipos de Operadores:** Familiarizarse con los operadores aritméticos, de asignación, de comparación, lógicos, bitwise, condicionales y de tipo.\n* **Comprender la Precedencia:** Aprender cómo la precedencia de los operadores afecta el orden de ejecución de las operaciones.\n* **Aplicar Operadores Correctamente:** Utilizar los operadores adecuados para realizar tareas específicas y evitar errores comunes.\n* **Optimizar el Código:** Escribir expresiones claras y eficientes utilizando operadores.\n\n## TIPOS DE OPERADORES\n\n### OPERADORES ARITMETICOS\n\nLos operadores aritméticos se utilizan para realizar cálculos matemáticos.\n\n* `+` **Suma**: Suma dos operandos.\n* `-` **Resta**: Resta el segundo operando del primero.\n* `*` **Multiplicación**: Multiplica dos operandos.\n* `/` **División**: Divide el primer operando por el segundo.\n* `%` **Módulo**: Devuelve el resto de la división del primer operando por el segundo.\n* `**` **Exponenciación**: Eleva el primer operando a la potencia del segundo.\n* `++` **Incremento**: Incrementa el valor de una variable en 1.\n* `--` **Decremento**: Decrementa el valor de una variable en 1.\n\n**Ejemplo:**\n\n```javascript\nlet x = 10;\r\nlet y = 5;\r\n\r\nconsole.log(x + y);   // 15\r\nconsole.log(x - y);   // 5\r\nconsole.log(x * y);   // 50\r\nconsole.log(x / y);   // 2\r\nconsole.log(x % y);   // 0\r\nconsole.log(x ** y);  // 100000\r\n\r\nx++;\r\nconsole.log(x);       // 11\r\n\r\ny--;\r\nconsole.log(y);       // 4\n```\n\n### OPERADORES DE ASIGNACION\n\nLos operadores de asignación se utilizan para asignar valores a las variables.\n\n* `=` **Asignación**: Asigna el valor del operando derecho al operando izquierdo.\n\n* `+=` **Suma y Asignación**: Suma el operando derecho al operando izquierdo y asigna el resultado al operando izquierdo.\n\n* `-=` **Resta y Asignación**: Resta el operando derecho del operando izquierdo y asigna el resultado al operando izquierdo.\n\n* `*=` **Multiplicación y Asignación**: Multiplica el operando izquierdo por el operando derecho y asigna el resultado al operando izquierdo.\n\n* `/=` **División y Asignación**: Divide el operando izquierdo por el operando derecho y asigna el resultado al operando izquierdo.\n\n* `%=` **Módulo y Asignación**: Calcula el módulo del operando izquierdo por el operando derecho y asigna el resultado al operando izquierdo.\n\n* `**=` **Exponenciación y Asignación**: Eleva el operando izquierdo a la potencia del operando derecho y asigna el resultado al operando izquierdo.\n\n**Ejemplo:**\n\n```javascript\nlet x = 10;\r\n\r\nx += 5;  // x = x + 5\r\nconsole.log(x);   // 15\r\n\r\nx -= 3;  // x = x - 3\r\nconsole.log(x);   // 12\r\n\r\nx *= 2;  // x = x * 2\r\nconsole.log(x);   // 24\r\n\r\nx /= 4;  // x = x / 4\r\nconsole.log(x);   // 6\r\n\r\nx %= 5;  // x = x % 5\r\nconsole.log(x);   // 1\r\n\r\nx **= 3; // x = x ** 3\r\nconsole.log(x);   // 1\n```\n\n### OPERADORES DE COMPARACION\n\nLos operadores de comparación se utilizan para comparar dos operandos y devolver un valor booleano (`true` o `false`).\n\n* `==` **Igual**: Devuelve `true` si los operandos son iguales en valor (después de la conversión de tipo, si es necesario).\n\n* `===` **Estrictamente Igual**: Devuelve true si los operandos son iguales en valor y tipo.\n\n* `!=` **No Igual**: Devuelve true si los operandos no son iguales en valor (después de la conversión de tipo, si es necesario).\n\n* `!==` **Estrictamente No Igual**: Devuelve true si los operandos no son iguales en valor o tipo.\n\n* `>` **Mayor Que**: Devuelve true si el operando izquierdo es mayor que el operando derecho.\n\n* `<` **Menor Que**: Devuelve true si el operando izquierdo es menor que el operando derecho.\n\n* `>=` **Mayor o Igual Que**: Devuelve true si el operando izquierdo es mayor o igual que el operando derecho.\n\n* `<=` **Menor o Igual Que**: Devuelve true si el operando izquierdo es menor o igual que el operando derecho.\n\n**Ejemplo**:\n\n```javascript\nlet x = 10;\r\nlet y = \"10\";\r\n\r\nconsole.log(x == y);   // true (comparación de valor después de la conversión de tipo)\r\nconsole.log(x === y);  // false (comparación de valor y tipo)\r\nconsole.log(x != y);   // false (comparación de valor después de la conversión de tipo)\r\nconsole.log(x !== y);  // true (comparación de valor y tipo)\r\n\r\nconsole.log(x > 5);    // true\r\nconsole.log(x < 12);   // true\r\nconsole.log(x >= 10);  // true\r\nconsole.log(x <= 9);   // false\n```\n\n### OPERADORES LOGICOS\n\nLos operadores lógicos se utilizan para combinar o modificar expresiones booleanas.\n\n* `&&` **AND Lógico**: Devuelve true si ambos operandos son true.\n\n* `||` **OR Lógico**: Devuelve true si al menos uno de los operandos es true.\n\n* `!` **NOT Lógico**: Devuelve true si el operando es false, y viceversa.\n\n**Ejemplo**:\n\n```javascript\nlet x = 5;\r\nlet y = 10;\r\n\r\nconsole.log(x > 0 && y < 20);  // true (ambas condiciones son verdaderas)\r\nconsole.log(x > 10 || y < 15); // true (al menos una condición es verdadera)\r\nconsole.log(!(x > 10));        // true (la condición es falsa, por lo que NOT la invierte)\n```\n\n### OPERADORES BITWISE\n\nLos operadores bitwise realizan operaciones a nivel de bits en los operandos.\n\n* `&` **AND Bitwise**: Realiza un AND bit a bit entre dos operandos.\n\n* `|` **OR Bitwise**: Realiza un OR bit a bit entre dos operandos.\n\n* `^` **XOR Bitwise**: Realiza un XOR bit a bit entre dos operandos.\n\n* `~` **NOT Bitwise**: Invierte los bits de un operando.\n\n* `<<` **Desplazamiento a la Izquierda**: Desplaza los bits de un operando a la izquierda.\n\n* `>>` **Desplazamiento a la Derecha**: Desplaza los bits de un operando a la derecha (conservando el signo).\n\n* `>>>` **Desplazamiento a la Derecha sin Signo**: Desplaza los bits de un operando a la derecha (rellenando con ceros).\n\n**Ejemplo**:\n\n```javascript\nlet x = 5;  // 0101 en binario\r\nlet y = 3;  // 0011 en binario\r\n\r\nconsole.log(x & y);   // 0001 (1 en decimal)\r\nconsole.log(x | y);   // 0111 (7 en decimal)\r\nconsole.log(x ^ y);   // 0110 (6 en decimal)\r\nconsole.log(~x);      // 1010 (complemento a dos, -6 en decimal)\r\nconsole.log(x << 1);  // 1010 (10 en decimal)\r\nconsole.log(x >> 1);  // 0010 (2 en decimal)\r\nconsole.log(x >>> 1); // 0010 (2 en decimal)\n```\n\n### OPERADOR CONDICIONAL (TERNARIO)\n\nEl operador condicional (ternario) es una forma abreviada de escribir una sentencia `if...else`.\n\n* `condición ? expresiónSiVerdadera : expresiónSiFalsa`\n\n**Ejemplo**:\n\n```javascript\nlet edad = 20;\r\nlet mensaje = (edad >= 18) ? \"Eres mayor de edad\" : \"Eres menor de edad\";\r\nconsole.log(mensaje);  // \"Eres mayor de edad\"\n```\n\n### OPERADORES DE TIPO\n\nLos operadores de tipo se utilizan para obtener información sobre el tipo de una variable o valor.\n\n* `typeof`: Devuelve una cadena que indica el tipo de un operando.\n\n* `instanceof`: Comprueba si un objeto es una instancia de una clase específica.\n\n**Ejemplo**:\n\n```javascript\nlet x = 10;\r\nlet nombre = \"Juan\";\r\nlet esMayor = true;\r\nlet persona = { nombre: \"Juan\", edad: 30 };\r\n\r\nconsole.log(typeof x);        // \"number\"\r\nconsole.log(typeof nombre);   // \"string\"\r\nconsole.log(typeof esMayor);  // \"boolean\"\r\nconsole.log(typeof persona);  // \"object\"\r\n\r\nconsole.log(persona instanceof Object);  // true\n```\n\n## PRECEDENCIA DE OPERADORES\n\nLa precedencia de operadores determina el orden en que se evalúan las operaciones en una expresión. Los operadores con mayor precedencia se evalúan primero. Es importante conocer la precedencia para asegurar que las expresiones se evalúen correctamente.\n\nA continuación, se muestra una lista de precedencia de operadores de mayor a menor:\n\n* `()` **Paréntesis**\n\n* `++`, `--` **Incremento/Decremento**\n\n* `**` **Exponenciación**\n\n* `*`, `/`, `%` **Multiplicación, División, Módulo**\n\n* `+`, `-` **Suma, Resta**\n\n* `<<`, `>>`, `>>>` **Desplazamiento de Bits**\n\n* `<`, `<=`, `>`, `>=` **Comparación**\n\n* `==`, `!=`, `===`, `!==` **Igualdad**\n\n* `&` **AND Bitwise**\n\n* `^` **XOR Bitwise**\n\n* `|` **OR Bitwise**\n\n* `&&` **AND Lógico**\n\n* `||` **OR Lógico**\n\n* `?:` **Operador Condicional**\n\n* `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=` **Asignación**\n\n* `typeof`, `instanceof` **Operadores de Tipo**\n\n**Ejemplo**:\n\n```javascript\nlet resultado = 5 + 10 * 2;  // Primero se realiza la multiplicación (10 * 2 = 20), luego la suma (5 + 20 = 25)\r\nconsole.log(resultado);       // 25\r\n\r\nlet resultado2 = (5 + 10) * 2; // Primero se realiza la suma dentro del paréntesis (5 + 10 = 15), luego la multiplicación (15 * 2 = 30)\r\nconsole.log(resultado2);      // 30\n```\n\n## CONCLUSION\n\nLos operadores son herramientas esenciales en JavaScript para realizar diversas operaciones y manipulaciones de datos. Conocer los diferentes tipos de operadores, su precedencia y cómo aplicarlos correctamente es crucial para escribir código eficiente y sin errores. Al dominar los operadores, los desarrolladores pueden crear aplicaciones más complejas y funcionales.\n\n## FUENTES DEL DOCUMENTO\n\n* [MDN Web Docs: Expressions and operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators)\n\n* [W3Schools: JavaScript Operators](https://www.w3schools.com/js/js_operators.asp)\n"
  },
  {
    "slug": "/programming/languages/javascript/javascript-fundamentals/variables-data-types",
    "title": "Variables y Tipos de Datos en JavaScript",
    "description": "Exploración profunda de las variables y los tipos de datos en JavaScript, incluyendo declaración, asignación, tipos primitivos y objetos.",
    "content": "JavaScript, como cualquier lenguaje de programación, se basa en la manipulación de datos. Para ello, utiliza variables que actúan como contenedores para almacenar información. Comprender cómo declarar variables y los diferentes tipos de datos que pueden contener es fundamental para escribir código JavaScript efectivo y eficiente.\n\n## OBJETIVOS CLAVE\n\n* Entender la diferencia entre `var`, `let` y `const` para la declaración de variables.\n* Conocer los tipos de datos primitivos en JavaScript: `string`, `number`, `boolean`, `null`, `undefined` y `symbol`.\n* Comprender el tipo de dato `object` y cómo se utiliza para estructuras de datos más complejas.\n* Aprender sobre la conversión de tipos (coerción) en JavaScript.\n\n## DECLARACION DE VARIABLES\n\nEn JavaScript, las variables se declaran utilizando las palabras clave `var`, `let` o `const`. Cada una tiene un comportamiento diferente en cuanto a su alcance (scope) y mutabilidad.\n\n### VAR\n\n* `var` fue la forma original de declarar variables en JavaScript.\n* Tiene un alcance de función (function scope) o global si se declara fuera de una función.\n* Permite la redeclaración y reasignación.\n\n```javascript\nvar x = 10;\r\n\r\nif (true) {\r\n  var x = 20;  // ¡Misma variable!\r\n  console.log(x);  // Imprime 20\r\n}\r\n\r\nconsole.log(x);  // Imprime 20 (¡cambió fuera del bloque!)\n```\n\n### LET\n\n* let se introdujo en ECMAScript 2015 (ES6) para solucionar los problemas de alcance de var.\n\n* Tiene un alcance de bloque (block scope), lo que significa que solo es accesible dentro del bloque en el que se define (por ejemplo, dentro de un `if`, `for`, o un bloque `{}`).\n\n* Permite la reasignación, pero no la redeclaración dentro del mismo alcance.\n\n```javascript\nlet y = 10;\r\n\r\nif (true) {\r\n  let y = 20;  // ¡Variable diferente!\r\n  console.log(y);  // Imprime 20\r\n}\r\n\r\nconsole.log(y);  // Imprime 10 (no cambió)\n```\n\n### CONST\n\n* `const` también se introdujo en ES6.\n\n* También tiene un alcance de bloque.\n\n* Se utiliza para declarar constantes, es decir, variables cuyo valor no debe cambiar después de la asignación inicial.\n\n* **Importante**: `const` no significa que el valor sea inmutable. Si const se usa para un objeto o un array, las propiedades del objeto o los elementos del array pueden modificarse, pero no se puede reasignar la variable a un nuevo objeto o array.\n\n```javascript\nconst z = 10;\r\n// z = 20;  // Error: Assignment to constant variable.\r\n\r\nconst obj = { nombre: \"Juan\" };\r\nobj.nombre = \"Pedro\";  // ¡Esto es válido!\r\nconsole.log(obj.nombre); // Imprime \"Pedro\"\r\n\r\n// obj = { nombre: \"Maria\" }; // Error: Assignment to constant variable.\n```\n\n## TIPOS DE DATOS PRIMITIVOS\n\nJavaScript tiene siete tipos de datos primitivos:\n\n### 1. String\n\nRepresenta datos textuales. Se delimita con comillas simples (`'...'`) o dobles (`\"...\"`).\n\n```javascript\nlet nombre = \"Juan Perez\";\r\nlet saludo = 'Hola mundo';\n```\n\n### 2. Number\n\nRepresenta valores numéricos, incluyendo enteros y números de punto flotante.\n\n```javascript\nlet edad = 30;\r\nlet precio = 99.99;\n```\n\n### 3. Boolean\n\nRepresenta un valor de verdad, que puede ser true o false.\n\n```javascript\nlet esMayorDeEdad = true;\r\nlet estaLogueado = false;\n```\n\n### 4. Null\n\nRepresenta la ausencia intencional de un valor. Es un valor asignado explícitamente.\n\n```javascript\nlet usuario = null; // Usuario no encontrado\n```\n\n### 5. Undefined\n\nRepresenta un valor que no ha sido asignado. Una variable declarada pero no inicializada tiene el valor undefined.\n\n```javascript\nlet direccion;\r\nconsole.log(direccion); // Imprime undefined\n```\n\n### 6. Symbol (Introducido en ES6)\n\nRepresenta un identificador único e inmutable. Se utiliza principalmente para añadir claves de propiedad únicas a los objetos.\n\n```javascript\nconst idUnico = Symbol(\"id\");\r\nconst obj = {\r\n  [idUnico]: 12345\r\n};\r\n\r\nconsole.log(obj[idUnico]); // Imprime 12345\n```\n\n### 7. BigInt: (Introducido en ES2020)\n\nRepresenta enteros de precisión arbitraria. Se utiliza para trabajar con números enteros que están fuera del rango seguro de `Number`.\n\n```javascript\nconst numeroGrande = 9007199254740991n;\n```\n\n## TIPO DE DATO OBJECT\n\nEl tipo de dato `object` es una colección de propiedades, donde cada propiedad tiene un nombre (clave) y un valor. Los objetos son fundamentales en JavaScript y se utilizan para representar estructuras de datos más complejas.\n\n```javascript\nlet persona = {\r\n  nombre: \"Ana\",\r\n  edad: 25,\r\n  ciudad: \"Madrid\"\r\n};\r\n\r\nconsole.log(persona.nombre); // Imprime \"Ana\"\r\nconsole.log(persona[\"edad\"]); // Imprime 25\n```\n\nLos arrays también son un tipo de objeto en JavaScript.\n\n```javascript\nlet colores = [\"rojo\", \"verde\", \"azul\"];\r\n\r\nconsole.log(colores[0]); // Imprime \"rojo\"\n```\n\n## CONVERSION DE TIPOS (COERCION)\n\nJavaScript es un lenguaje de tipado dinámico, lo que significa que el tipo de una variable puede cambiar durante la ejecución del programa. JavaScript también realiza la conversión automática de tipos (coerción) en ciertas operaciones.\n\n### EJEMPLOS DE COERCION\n\n* **Suma con strings**: Si se suma un número con un string, JavaScript convierte el número a string y realiza la concatenación.\n\n  ```javascript\n  let resultado = \"El resultado es: \" + 10 + 20;\r\n  console.log(resultado); // Imprime \"El resultado es: 1020\"\n  ```\n\n* **Operaciones booleanas**: En contextos booleanos (como en un `if` o un bucle), JavaScript convierte automáticamente ciertos valores a `true` o `false`. Los valores \"falsy\" son: `0`, `null`, `undefined`, `NaN`, `\"\"` (string vacío) y `false`. Todos los demás valores se consideran \"truthy\".\n\n```javascript\nif (\"\") {\r\n  console.log(\"Esto no se imprimirá\");\r\n}\r\n\r\nif (10) {\r\n  console.log(\"Esto se imprimirá\");\r\n}\n```\n\n## CONVERSION EXPLICITA\n\nEs posible realizar la conversión de tipos de forma explícita utilizando funciones como:\n\n* `Number()`: Convierte un valor a número.\n\n* `String()`: Convierte un valor a string.\n\n* `Boolean()`: Convierte un valor a booleano.\n\n* `parseInt()`: Convierte un string a un entero.\n\n* `parseFloat()`: Convierte un string a un número de punto flotante.\n\n```javascript\nlet numeroString = \"42\";\r\nlet numero = Number(numeroString);\r\nconsole.log(typeof numero); // Imprime \"number\"\r\n\r\nlet valorBooleano = Boolean(0);\r\nconsole.log(valorBooleano); // Imprime false\n```\n\n## CONCLUSION\n\nComprender las variables y los tipos de datos en JavaScript es esencial para escribir código robusto y predecible. Utilizar `let` y `const` en lugar de `var` ayuda a evitar errores relacionados con el alcance de las variables. Conocer los tipos de datos primitivos y cómo JavaScript realiza la conversión de tipos permite escribir código más eficiente y evitar sorpresas inesperadas.\n\n## FUENTES DEL DOCUMENTO\n\n[MDN Web Docs: JavaScript Data types and data structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)\n\n[MDN Web Docs: var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)\n\n[MDN Web Docs: let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)\n\n[MDN Web Docs: const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)\n"
  },
  {
    "slug": "/programming/languages/python/control-structure",
    "title": "Estructuras de Control en Python",
    "description": "Una guía completa sobre las estructuras de control en Python, incluyendo condicionales, bucles y manejo de excepciones.",
    "content": "Las estructuras de control son elementos fundamentales en cualquier lenguaje de programación, ya que permiten dirigir el flujo de ejecución de un programa. En Python, estas estructuras se caracterizan por su sintaxis clara y legible, lo que facilita la escritura de código eficiente y mantenible. Este documento explora en detalle las estructuras de control en Python, incluyendo condicionales (`if`, `else`, `elif`), bucles (`for`, `while`) y el manejo de excepciones (`try`, `except`).\n\n## CONDICIONES: if, else, elif\n\nLas sentencias condicionales permiten ejecutar diferentes bloques de código dependiendo de si una condición es verdadera o falsa.\n\n* **`if`**: Ejecuta un bloque de código si la condición es verdadera.\n\n  ```python\n  edad = 20\r\n  if edad >= 18:\r\n      print(\"Eres mayor de edad\")\n  ```\n* **`else`**: Ejecuta un bloque de código si la condición del `if` es falsa.\n\n  ```python\n  edad = 16\r\n  if edad >= 18:\r\n      print(\"Eres mayor de edad\")\r\n  else:\r\n      print(\"Eres menor de edad\")\n  ```\n* **`elif`**: Permite evaluar múltiples condiciones en secuencia. Es una contracción de \"else if\".\n\n  ```python\n  calificacion = 75\r\n  if calificacion >= 90:\r\n      print(\"Excelente\")\r\n  elif calificacion >= 80:\r\n      print(\"Notable\")\r\n  elif calificacion >= 70:\r\n      print(\"Aprobado\")\r\n  else:\r\n      print(\"Reprobado\")\n  ```\n\n## BUCLES: for, while\n\nLos bucles permiten ejecutar un bloque de código repetidamente. Python ofrece dos tipos principales de bucles: `for` y `while`.\n\n* **`for`**: Itera sobre una secuencia (como una lista, tupla, cadena) o cualquier objeto iterable.\n\n  ```python\n  frutas = [\"manzana\", \"banana\", \"cereza\"]\r\n  for fruta in frutas:\r\n      print(fruta)\n  ```\n\n  También se utiliza comúnmente con la función `range()` para iterar un número específico de veces.\n\n  ```python\n  for i in range(5):\r\n      print(i)  # Imprime 0, 1, 2, 3, 4\n  ```\n* **`while`**: Ejecuta un bloque de código mientras una condición sea verdadera.\n\n  ```python\n  contador = 0\r\n  while contador < 5:\r\n      print(contador)\r\n      contador += 1\n  ```\n\n  Es importante asegurarse de que la condición del `while` eventualmente se vuelva falsa para evitar un bucle infinito.\n\n## MANEJO DE EXCEPCIONES: try, except\n\nEl manejo de excepciones permite controlar errores que pueden ocurrir durante la ejecución de un programa.\n\n* **`try`**: Encierra el código que puede generar una excepción.\n* **`except`**: Captura y maneja la excepción si ocurre.\n\n  ```python\n  try:\r\n      resultado = 10 / 0\r\n  except ZeroDivisionError:\r\n      print(\"Error: División por cero\")\n  ```\n\n  También se puede incluir un bloque `else` que se ejecuta si no se produce ninguna excepción en el bloque `try`, y un bloque `finally` que se ejecuta siempre, independientemente de si se produjo o no una excepción.\n\n  ```python\n  try:\r\n      resultado = 10 / 2\r\n  except ZeroDivisionError:\r\n      print(\"Error: División por cero\")\r\n  else:\r\n      print(\"El resultado es:\", resultado)\r\n  finally:\r\n      print(\"Fin del bloque try-except\")\n  ```\n\n## OBJETIVOS CLAVE\n\n* **Control del Flujo**: Las estructuras de control permiten dirigir el flujo de ejecución de un programa, ejecutando diferentes bloques de código según las condiciones y repitiendo acciones cuando sea necesario.\n* **Manejo de Errores**: El manejo de excepciones permite controlar errores que pueden ocurrir durante la ejecución de un programa, evitando que el programa se detenga abruptamente.\n* **Legibilidad y Mantenibilidad**: El uso adecuado de las estructuras de control mejora la legibilidad y mantenibilidad del código, facilitando su comprensión y modificación.\n\n## EJEMPLO DE IMPLEMENTACION\n\n### EJEMPLO 1: CALCULADORA SIMPLE\n\n```python\ndef calculadora():\r\n    operacion = input(\"Ingrese la operación a realizar (+, -, *, /): \")\r\n    num1 = float(input(\"Ingrese el primer número: \"))\r\n    num2 = float(input(\"Ingrese el segundo número: \"))\r\n\r\n    if operacion == '+':\r\n        resultado = num1 + num2\r\n    elif operacion == '-':\r\n        resultado = num1 - num2\r\n    elif operacion == '*':\r\n        resultado = num1 * num2\r\n    elif operacion == '/':\r\n        try:\r\n            resultado = num1 / num2\r\n        except ZeroDivisionError:\r\n            print(\"Error: No se puede dividir por cero.\")\r\n            return\r\n    else:\r\n        print(\"Operación no válida.\")\r\n        return\r\n\r\n    print(\"El resultado es:\", resultado)\r\n\r\ncalculadora()\n```\n\n### EJEMPLO 2: BUSQUEDA EN UNA LISTA\n\n```python\ndef buscar_elemento(lista, elemento):\r\n    for i in range(len(lista)):\r\n        if lista[i] == elemento:\r\n            print(\"Elemento encontrado en el índice:\", i)\r\n            return\r\n    print(\"Elemento no encontrado en la lista.\")\r\n\r\nmi_lista = [10, 20, 30, 40, 50]\r\nbuscar_elemento(mi_lista, 30)\r\nbuscar_elemento(mi_lista, 60)\n```\n\n## SUBTEMAS SUGERIDOS\n\n* **Sentencias break y continue**: Controlar el flujo de los bucles.\n\n* **Comprensión de Listas**: Una forma concisa de crear listas utilizando bucles y condicionales.\n\n* **Iteradores y Generadores**: Formas avanzadas de iterar sobre secuencias.\n\n* **Manejo de Múltiples Excepciones**: Capturar y manejar diferentes tipos de excepciones.\n"
  },
  {
    "slug": "/programming/languages/python/data-types/dictionary-operations",
    "title": "Operaciones con Diccionarios en Python",
    "description": "Guía completa sobre las operaciones esenciales que puedes realizar con diccionarios en Python, incluyendo creación, acceso, modificación, eliminación y métodos avanzados.",
    "content": "Los diccionarios en Python son una de las estructuras de datos más versátiles y utilizadas. Permiten almacenar datos en pares clave-valor, lo que facilita la búsqueda y manipulación de información. Este documento detalla las operaciones fundamentales que puedes realizar con diccionarios, desde la creación hasta métodos más avanzados.\n\n## Creación de Diccionarios\n\nUn diccionario se crea utilizando llaves `{}` y definiendo pares clave-valor separados por dos puntos `:`.\n\n```python\n# Diccionario vacío\r\ndiccionario_vacio = {}\r\n\r\n# Diccionario con valores iniciales\r\npersona = {\r\n    \"nombre\": \"Juan\",\r\n    \"edad\": 30,\r\n    \"ciudad\": \"Madrid\"\r\n}\n```\n\n## ACCESO A ELEMENTOS\n\nPara acceder a un valor en un diccionario, se utiliza la clave correspondiente entre corchetes `[]`.\n\n```python\nnombre = persona[\"nombre\"]  # Accede al valor de la clave \"nombre\"\r\nprint(nombre)  # Output: Juan\n```\n\nTambién puedes utilizar el método `get()` para acceder a un valor. La ventaja de `get()` es que permite especificar un valor por defecto si la clave no existe.\n\n```python\napellido = persona.get(\"apellido\", \"Desconocido\")  # Si \"apellido\" no existe, devuelve \"Desconocido\"\r\nprint(apellido)  # Output: Desconocido\n```\n\n## MODIFICACION DE ELEMENTOS\n\nLos diccionarios son mutables, lo que significa que puedes modificar sus valores, añadir nuevas claves o eliminar claves existentes.\n\n```python\n# Modificar un valor existente\r\npersona[\"edad\"] = 31\r\n\r\n# Añadir un nuevo par clave-valor\r\npersona[\"profesion\"] = \"Ingeniero\"\r\n\r\nprint(persona)\r\n# Output: {'nombre': 'Juan', 'edad': 31, 'ciudad': 'Madrid', 'profesion': 'Ingeniero'}\n```\n\n## ELIMINACION DE ELEMENTOS\n\nPara eliminar un elemento de un diccionario, puedes utilizar la sentencia del o los métodos `pop()` y `popitem()`.\n\n```python\n# Eliminar un elemento con del\r\ndel persona[\"ciudad\"]\r\n\r\n# Eliminar un elemento con pop()\r\nedad = persona.pop(\"edad\")  # Elimina la clave \"edad\" y devuelve su valor\r\nprint(edad)  # Output: 31\r\n\r\n# Eliminar el último elemento insertado con popitem()\r\nultimo_elemento = persona.popitem()  # Elimina y devuelve el último par clave-valor\r\nprint(ultimo_elemento)  # Output: ('profesion', 'Ingeniero')\r\n\r\nprint(persona)  # Output: {'nombre': 'Juan'}\n```\n\n## METODOS DE DICCIONARIO\n\nPython proporciona varios métodos útiles para trabajar con diccionarios:\n\n* **keys()**: Devuelve una vista de todas las claves del diccionario.\n\n* **values()**: Devuelve una vista de todos los valores del diccionario.\n\n* **items()**: Devuelve una vista de todos los pares clave-valor del diccionario.\n\n* **update()**: Actualiza el diccionario con los elementos de otro diccionario o un iterable de pares clave-valor.\n\n* **clear()**: Elimina todos los elementos del diccionario.\n\n* **copy()**: Devuelve una copia superficial del diccionario.\n\n```python\npersona = {\r\n    \"nombre\": \"Juan\",\r\n    \"edad\": 30,\r\n    \"ciudad\": \"Madrid\"\r\n}\r\n\r\n# keys()\r\nclaves = persona.keys()\r\nprint(claves)  # Output: dict_keys(['nombre', 'edad', 'ciudad'])\r\n\r\n# values()\r\nvalores = persona.values()\r\nprint(valores)  # Output: dict_values(['Juan', 30, 'Madrid'])\r\n\r\n# items()\r\nelementos = persona.items()\r\nprint(elementos)  # Output: dict_items([('nombre', 'Juan'), ('edad', 30), ('ciudad', 'Madrid')])\r\n\r\n# update()\r\npersona.update({\"profesion\": \"Ingeniero\", \"pais\": \"España\"})\r\nprint(persona)  # Output: {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Madrid', 'profesion': 'Ingeniero', 'pais': 'España'}\r\n\r\n# clear()\r\n# persona.clear()\r\n# print(persona)  # Output: {}\r\n\r\n# copy()\r\npersona_copia = persona.copy()\r\nprint(persona_copia)  # Output: {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Madrid', 'profesion': 'Ingeniero', 'pais': 'España'}\n```\n\n## ITERACCION SOBRE DICCIONARIOS\n\nPuedes iterar sobre un diccionario utilizando un bucle `for`. Por defecto, la iteración se realiza sobre las claves.\n\n```python\nfor clave in persona:\r\n    print(clave, persona[clave])\n```\n\nTambién puedes iterar sobre los valores o los pares clave-valor utilizando los métodos `values()` e `items()`, respectivamente.\n\n```python\n# Iterar sobre los valores\r\nfor valor in persona.values():\r\n    print(valor)\r\n\r\n# Iterar sobre los pares clave-valor\r\nfor clave, valor in persona.items():\r\n    print(clave, valor)\n```\n\n## COMPRESION DE DICCIONARIOS\n\nAl igual que las listas, los diccionarios también admiten la comprensión, lo que permite crear diccionarios de manera concisa.\n\n```python\n# Crear un diccionario con los cuadrados de los números del 1 al 5\r\ncuadrados = {x: x**2 for x in range(1, 6)}\r\nprint(cuadrados)  # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n```\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### CONTEO DE FRECUENCIA DE PALABRAS\n\nUn ejemplo común es contar la frecuencia de palabras en un texto.\n\n```python\ntexto = \"Este es un ejemplo de texto para contar palabras. Este texto es un ejemplo.\"\r\npalabras = texto.lower().split()\r\n\r\nfrecuencia = {}\r\nfor palabra in palabras:\r\n    if palabra in frecuencia:\r\n        frecuencia[palabra] += 1\r\n    else:\r\n        frecuencia[palabra] = 1\r\n\r\nprint(frecuencia)\r\n# Output: {'este': 2, 'es': 2, 'un': 2, 'ejemplo': 2, 'de': 1, 'texto': 2, 'para': 1, 'contar': 1, 'palabras.': 1, 'texto.': 1}\n```\n\n### AGRUPACION DE DATOS\n\nOtro uso común es agrupar datos relacionados.\n\n```python\nestudiantes = [\r\n    {\"nombre\": \"Ana\", \"edad\": 20, \"carrera\": \"Ingeniería\"},\r\n    {\"nombre\": \"Pedro\", \"edad\": 22, \"carrera\": \"Medicina\"},\r\n    {\"nombre\": \"Sofia\", \"edad\": 21, \"carrera\": \"Ingeniería\"}\r\n]\r\n\r\n# Agrupar estudiantes por carrera\r\ncarreras = {}\r\nfor estudiante in estudiantes:\r\n    carrera = estudiante[\"carrera\"]\r\n    if carrera in carreras:\r\n        carreras[carrera].append(estudiante[\"nombre\"])\r\n    else:\r\n        carreras[carrera] = [estudiante[\"nombre\"]]\r\n\r\nprint(carreras)\r\n# Output: {'Ingeniería': ['Ana', 'Sofia'], 'Medicina': ['Pedro']}\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types",
    "title": "Tipos de Datos en Python",
    "description": "Explora los diferentes tipos de datos disponibles en Python, incluyendo tipos numéricos, cadenas, booleanos y estructuras de datos como listas, tuplas, diccionarios y conjuntos.",
    "content": "Python ofrece una variedad de tipos de datos incorporados que permiten a los programadores representar y manipular diferentes tipos de información. Comprender estos tipos de datos es fundamental para escribir código eficiente y efectivo en Python.\n\n## TIPOS DE DATOS PRIMITIVOS\n\nLos tipos de datos primitivos son los bloques de construcción básicos de los datos en Python.\n\n1. **Números:**\n   * **Enteros (`int`):** Representan números enteros sin parte decimal.\n     * Ejemplo: `10`, `-5`, `0`\n   * **Números de Punto Flotante (`float`):** Representan números reales con parte decimal.\n     * Ejemplo: `3.14`, `-2.5`, `0.0`\n   * **Números Complejos (`complex`):** Representan números con una parte real y una parte imaginaria.\n     * Ejemplo: `2 + 3j`, `-1 - 1j`\n\n2. **Cadenas (`str`):**\n   * Representan secuencias de caracteres. Las cadenas son inmutables, lo que significa que no se pueden modificar después de su creación.\n     * Ejemplo: `\"Hola\"`, `'Python'`, `\"123\"`\n\n3. **Booleanos (`bool`):**\n   * Representan valores de verdad: `True` o `False`.\n     * Ejemplo: `True`, `False`\n\n## ESTRUCTURA DE DATOS\n\nLas estructuras de datos son contenedores que pueden almacenar múltiples elementos de datos.\n\n1. **Listas (`list`):**\n   * Son colecciones ordenadas y mutables de elementos. Los elementos pueden ser de diferentes tipos.\n     * Ejemplo: `[1, 2, 3]`, `[\"a\", \"b\", \"c\"]`, `[1, \"hello\", 3.14]`\n\n2. **Tuplas (`tuple`):**\n   * Son colecciones ordenadas e inmutables de elementos. Similar a las listas, pero no se pueden modificar después de su creación.\n     * Ejemplo: `(1, 2, 3)`, `(\"a\", \"b\", \"c\")`\n\n3. **Diccionarios (`dict`):**\n   * Son colecciones de pares clave-valor. Las claves deben ser únicas e inmutables (por ejemplo, cadenas, números o tuplas), mientras que los valores pueden ser de cualquier tipo.\n     * Ejemplo: `{\"nombre\": \"Juan\", \"edad\": 30}`, `{1: \"a\", 2: \"b\"}`\n\n4. **Conjuntos (`set`):**\n   * Son colecciones no ordenadas de elementos únicos. Los conjuntos son mutables y se utilizan para realizar operaciones de conjuntos como unión, intersección y diferencia.\n     * Ejemplo: `{1, 2, 3}`, `{\"a\", \"b\", \"c\"}`\n\n## TIPADO DINAMICO\n\nPython es un lenguaje de tipado dinámico, lo que significa que no es necesario declarar el tipo de una variable antes de usarla. El tipo de una variable se determina en tiempo de ejecución en función del valor que se le asigna.\n\n```python\nx = 10        # x es un entero\r\nx = \"Hola\"    # x ahora es una cadena\r\nx = [1, 2, 3] # x ahora es una lista\n```\n\n## MUTABILIDAD VS INMUTABILIDAD\n\nLa mutabilidad se refiere a la capacidad de un objeto para ser modificado después de su creación.\n\nTipos Mutables: Listas, diccionarios y conjuntos son tipos de datos mutables. Esto significa que se pueden modificar sus elementos después de su creación.\n\nTipos Inmutables: Enteros, números de punto flotante, cadenas, booleanos y tuplas son tipos de datos inmutables. Esto significa que no se pueden modificar después de su creación. Si se intenta modificar un objeto inmutable, se creará un nuevo objeto en su lugar.\n\n## OBJETIVOS CLAVE\n\nComprender los Tipos de Datos: Familiarizarse con los diferentes tipos de datos disponibles en Python y cómo se utilizan para representar diferentes tipos de información.\n\nDistinguir Mutabilidad e Inmutabilidad: Entender la diferencia entre tipos de datos mutables e inmutables y cómo esto afecta la forma en que se manipulan los datos.\n\nElegir el Tipo de Datos Correcto: Aprender a seleccionar el tipo de datos más apropiado para cada situación, teniendo en cuenta factores como la necesidad de mutabilidad, la eficiencia y la legibilidad del código.\n\nUtilizar Estructuras de Datos: Dominar el uso de estructuras de datos como listas, tuplas, diccionarios y conjuntos para organizar y manipular colecciones de datos de manera eficiente.\n\n## INFORMACION INTERESANTE\n\nConversión de Tipos: Python permite convertir entre diferentes tipos de datos utilizando funciones como int(), float(), str(), list(), tuple(), dict() y set().\n\nOperadores: Python ofrece una variedad de operadores para realizar operaciones en diferentes tipos de datos, como operadores aritméticos, operadores de comparación, operadores lógicos y operadores de pertenencia.\n\nMétodos: Cada tipo de datos en Python tiene una serie de métodos asociados que permiten realizar operaciones específicas en los datos. Por ejemplo, las cadenas tienen métodos como upper(), lower(), split() y replace().\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO 1: TIPOS NUMERICOS\n\n```python\nentero = 10\r\nflotante = 3.14\r\ncomplejo = 2 + 3j\r\n\r\nprint(type(entero))    # <class 'int'>\r\nprint(type(flotante))  # <class 'float'>\r\nprint(type(complejo))  # <class 'complex'>\n```\n\n### EJEMPLO 2: CADENAS\n\n```python\ncadena = \"Hola, mundo!\"\r\nprint(cadena)           # Hola, mundo!\r\nprint(cadena[0])        # H\r\nprint(len(cadena))      # 13\n```\n\n### EJEMPLO 3: LISTAS\n\n```python\nlista = [1, 2, 3, \"a\", \"b\", \"c\"]\r\nprint(lista)            # [1, 2, 3, 'a', 'b', 'c']\r\nlista.append(4)\r\nprint(lista)            # [1, 2, 3, 'a', 'b', 'c', 4]\n```\n\n### EJEMPLO 4: TUPLAS\n\n```python\ntupla = (1, 2, 3)\r\nprint(tupla)            # (1, 2, 3)\r\n# tupla[0] = 4          # Error: 'tuple' object does not support item assignment\n```\n\n### EJEMPLO 5: DICCIONARIO\n\n```python\ndiccionario = {\"nombre\": \"Juan\", \"edad\": 30}\r\nprint(diccionario[\"nombre\"])  # Juan\r\ndiccionario[\"ciudad\"] = \"Madrid\"\r\nprint(diccionario)            # {'nombre': 'Juan', 'edad': 30, 'ciudad': 'Madrid'}\n```\n\n### EJEMPLO 6: CONJUNTOS\n\n```python\nconjunto = {1, 2, 3, 3, 4, 5}\r\nprint(conjunto)           # {1, 2, 3, 4, 5}\r\nconjunto.add(6)\r\nprint(conjunto)           # {1, 2, 3, 4, 5, 6}\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types/list-operations",
    "title": "Operaciones con Listas en Python",
    "description": "Guía completa sobre las operaciones fundamentales que se pueden realizar con listas en Python, incluyendo acceso, modificación, adición, eliminación y manipulación avanzada de elementos.",
    "content": "Las listas en Python son una de las estructuras de datos más versátiles y utilizadas. Permiten almacenar colecciones ordenadas de elementos, que pueden ser de diferentes tipos. Dominar las operaciones con listas es esencial para cualquier programador de Python, ya que facilita la manipulación y el procesamiento de datos de manera eficiente.\n\n## INTRODUCCION A LAS LISTAS EN PYTHON\n\nUna lista en Python es una secuencia mutable de elementos. Esto significa que puedes cambiar los elementos de una lista después de su creación. Las listas se definen utilizando corchetes `[]` y los elementos se separan por comas.\n\n```python\nmi_lista = [1, 2, 3, \"a\", \"b\", \"c\", 4.5, 5.6]\n```\n\n## OPERACIONES BASICAS CON LISTAS\n\n### 1. ACCESO A ELEMENTOS\n\nPuedes acceder a los elementos de una lista utilizando su índice. Los índices en Python comienzan en 0.\n\n```python\nmi_lista = [10, 20, 30, 40, 50]\r\nprint(mi_lista[0])  # Imprime 10\r\nprint(mi_lista[3])  # Imprime 40\n```\n\nTambién puedes utilizar índices negativos para acceder a los elementos desde el final de la lista.\n\n```python\nprint(mi_lista[-1]) # Imprime 50 (el último elemento)\r\nprint(mi_lista[-2]) # Imprime 40 (el penúltimo elemento)\n```\n\n### 2. MODIFICACION DE ELEMENTOS\n\nLas listas son mutables, lo que significa que puedes cambiar el valor de un elemento específico.\n\n```python\nmi_lista = [1, 2, 3]\r\nmi_lista[1] = 10\r\nprint(mi_lista)  # Imprime [1, 10, 3]\n```\n\n### 3. ADICION DE ELEMENTOS\n\nEl método `append()` añade un elemento al final de la lista.\n\n```python\nmi_lista = [1, 2, 3]\r\nmi_lista.append(4)\r\nprint(mi_lista)  # Imprime [1, 2, 3, 4]\n```\n\nEl método `insert()` añade un elemento en una posición específica.\n\n```python\nmi_lista = [1, 2, 3]\r\nmi_lista.insert(1, 10)  # Inserta 10 en la posición 1\r\nprint(mi_lista)  # Imprime [1, 10, 2, 3]\n```\n\nEl método `extend()` añade múltiples elementos de otra lista (o cualquier iterable) al final de la lista actual.\n\n```python\nmi_lista = [1, 2, 3]\r\notra_lista = [4, 5, 6]\r\nmi_lista.extend(otra_lista)\r\nprint(mi_lista)  # Imprime [1, 2, 3, 4, 5, 6]\n```\n\n### 4. ELIMINACION DE ELEMENTOS\n\nEl método `remove()` elimina la primera ocurrencia de un valor específico de la lista.\n\n```python\nmi_lista = [1, 2, 3, 2]\r\nmi_lista.remove(2)\r\nprint(mi_lista)  # Imprime [1, 3, 2]\n```\n\nEl método `pop()` elimina el elemento en una posición específica y lo retorna. Si no se especifica la posición, elimina y retorna el último elemento.\n\n```python\nmi_lista = [1, 2, 3]\r\nelemento = mi_lista.pop(1)  # Elimina el elemento en la posición 1 (2)\r\nprint(mi_lista)  # Imprime [1, 3]\r\nprint(elemento)  # Imprime 2\r\n\r\nelemento = mi_lista.pop()   # Elimina el último elemento (3)\r\nprint(mi_lista)  # Imprime [1]\r\nprint(elemento)  # Imprime 3\n```\n\nLa palabra clave `del` elimina un elemento en una posición específica o la lista completa.\n\n```python\nmi_lista = [1, 2, 3]\r\ndel mi_lista[1]\r\nprint(mi_lista)  # Imprime [1, 3]\r\n\r\ndel mi_lista  # Elimina la lista\r\n# print(mi_lista)  # Esto causará un error porque la lista ya no existe\n```\n\n### 5. BUSQUEDA DE ELEMENTOS\n\nEl método `index()` retorna el índice de la primera ocurrencia de un valor específico.\n\n```python\nmi_lista = [10, 20, 30, 20]\r\nindice = mi_lista.index(20)\r\nprint(indice)  # Imprime 1\n```\n\nSi el valor no está en la lista, se genera una excepción `ValueError`.\n\nEl método `count()` retorna el número de veces que un valor aparece en la lista.\n\n```python\nmi_lista = [10, 20, 30, 20, 20]\r\nconteo = mi_lista.count(20)\r\nprint(conteo)  # Imprime 3\n```\n\n### 6. ORDENAMIENTO DE LISTAS\n\nEl método `sort()` ordena la lista en su lugar (modifica la lista original).\n\n```python\nmi_lista = [3, 1, 4, 1, 5, 9, 2, 6]\r\nmi_lista.sort()\r\nprint(mi_lista)  # Imprime [1, 1, 2, 3, 4, 5, 6, 9]\r\n\r\nmi_lista.sort(reverse=True)  # Ordena en orden descendente\r\nprint(mi_lista)  # Imprime [9, 6, 5, 4, 3, 2, 1, 1]\n```\n\nLa función `sorted()` retorna una nueva lista ordenada sin modificar la lista original.\n\n```python\nmi_lista = [3, 1, 4, 1, 5, 9, 2, 6]\r\nnueva_lista = sorted(mi_lista)\r\nprint(nueva_lista)  # Imprime [1, 1, 2, 3, 4, 5, 6, 9]\r\nprint(mi_lista)     # Imprime [3, 1, 4, 1, 5, 9, 2, 6] (la lista original no se modifica)\n```\n\n### 7. INVERSION DE LISTAS\n\nEl método `reverse()` invierte el orden de los elementos en la lista en su lugar.\n\n```python\nmi_lista = [1, 2, 3, 4, 5]\r\nmi_lista.reverse()\r\nprint(mi_lista)  # Imprime [5, 4, 3, 2, 1]\n```\n\n### 8. COPIA DE LISTAS\n\nEl método `copy()` retorna una copia superficial de la lista.\n\n```python\nmi_lista = [1, 2, 3]\r\ncopia_lista = mi_lista.copy()\r\nprint(copia_lista)  # Imprime [1, 2, 3]\r\n\r\nmi_lista[0] = 10\r\nprint(mi_lista)     # Imprime [10, 2, 3]\r\nprint(copia_lista)  # Imprime [1, 2, 3] (la copia no se modifica)\n```\n\nTambién puedes usar la función `list()` para crear una copia de la lista.\n\n```python\nmi_lista = [1, 2, 3]\r\ncopia_lista = list(mi_lista)\r\nprint(copia_lista)  # Imprime [1, 2, 3]\n```\n\n### 9. LIMPIEZA DE LISTAS\n\nEl método `clear()` elimina todos los elementos de la lista, dejándola vacía.\n\n```python\nmi_lista = [1, 2, 3]\r\nmi_lista.clear()\r\nprint(mi_lista)  # Imprime []\n```\n\n## OPERACIONES AVANZADAS CON LISTAS\n\n### 1. CONCATENACION DE LISTAS\n\nPuedes concatenar listas utilizando el operador `+`.\n\n```python\nlista1 = [1, 2, 3]\r\nlista2 = [4, 5, 6]\r\nlista_concatenada = lista1 + lista2\r\nprint(lista_concatenada)  # Imprime [1, 2, 3, 4, 5, 6]\n```\n\n### 2. MULTIPLICACION DE LISTAS\n\nPuedes multiplicar una lista por un número entero para repetir sus elementos.\n\n```python\nmi_lista = [1, 2, 3]\r\nlista_multiplicada = mi_lista * 3\r\nprint(lista_multiplicada)  # Imprime [1, 2, 3, 1, 2, 3, 1, 2, 3]\n```\n\n### 3. COMPRENSION DE LISTAS\n\nLa comprensión de listas es una forma concisa de crear listas en Python. Permite generar una nueva lista aplicando una expresión a cada elemento de una lista existente.\n\n```python\n# Ejemplo: Crear una lista con los cuadrados de los números del 0 al 9\r\ncuadrados = [x**2 for x in range(10)]\r\nprint(cuadrados)  # Imprime [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\r\n\r\n# Ejemplo: Crear una lista con los números pares del 0 al 9\r\npares = [x for x in range(10) if x % 2 == 0]\r\nprint(pares)  # Imprime [0, 2, 4, 6, 8]\n```\n\n### 4. LISTAS ANIDADAS\n\nLas listas pueden contener otras listas como elementos.\n\n```python\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\nprint(matriz[0][1])  # Imprime 2 (elemento en la fila 0, columna 1)\n```\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO 1: FILTRAR ELEMENTOS DE UNA LISTA\n\n```python\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\npares = [x for x in numeros if x % 2 == 0]\r\nimpares = [x for x in numeros if x % 2 != 0]\r\n\r\nprint(\"Números pares:\", pares)    # Imprime [2, 4, 6, 8, 10]\r\nprint(\"Números impares:\", impares)  # Imprime [1, 3, 5, 7, 9]\n```\n\n### EJEMPLO 2: PROCESAR ELEMENTOS DE UNA LISTA\n\n```python\npalabras = [\"hola\", \"mundo\", \"python\"]\r\nlongitudes = [len(palabra) for palabra in palabras]\r\n\r\nprint(\"Longitudes de las palabras:\", longitudes)  # Imprime [4, 5, 6]\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types/list-operations/map-filter-reduce",
    "title": "Funciones map(), filter() y reduce() en Python",
    "description": "Descripción detallada de las funciones map(), filter() y reduce() en Python, incluyendo ejemplos de uso y consideraciones importantes.",
    "content": "Las funciones `map()`, `filter()` y `reduce()` son herramientas poderosas en Python que permiten aplicar operaciones a secuencias de datos de manera concisa y eficiente. Estas funciones son pilares de la programación funcional en Python y facilitan la escritura de código más limpio y legible.\n\n## DESCRIPCION GENERAL\n\n* **`map()`**: Aplica una función a cada elemento de un iterable (como una lista) y devuelve un iterador con los resultados.\n* **`filter()`**: Filtra los elementos de un iterable basándose en una función que devuelve `True` o `False` para cada elemento.\n* **`reduce()`**: Aplica una función de dos argumentos acumulativamente a los elementos de un iterable, reduciéndolo a un solo valor.\n\n## OBJETIVOS CLAVE\n\n* Entender el propósito y la sintaxis de cada función.\n* Aprender a usar estas funciones con funciones anónimas (lambda).\n* Comprender cómo estas funciones pueden simplificar el código y mejorar la eficiencia.\n* Conocer las alternativas modernas a `map()`, `filter()` y `reduce()` en Python 3.\n\n## map()\n\nLa función `map()` toma dos argumentos: una función y un iterable. Aplica la función a cada elemento del iterable y devuelve un iterador que produce los resultados.\n\n### SINTAXIS map()\n\n```python\nmap(function, iterable, ...)\n```\n\n* **function**: La función que se aplicará a cada elemento del iterable.\n\n* **iterable**: Uno o más iterables sobre los cuales se aplicará la función.\n\n### EJEMPLOS DE IMPLEMENTACION map()\n\n```python\ndef cuadrado(x):\r\n    return x * x\r\n\r\nnumeros = [1, 2, 3, 4, 5]\r\nresultados = map(cuadrado, numeros)\r\n\r\nprint(list(resultados))  # Output: [1, 4, 9, 16, 25]\n```\n\nEn este ejemplo, la función cuadrado se aplica a cada número en la lista numeros. La función map() devuelve un iterador, que luego se convierte en una lista para imprimir los resultados.\n\n### USO CON FUNCIONES LAMBDA map()\n\nLas funciones lambda son pequeñas funciones anónimas que se pueden definir en línea. Son especialmente útiles con `map()` para operaciones simples.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\r\nresultados = map(lambda x: x * x, numeros)\r\n\r\nprint(list(resultados))  # Output: [1, 4, 9, 16, 25]\n```\n\nEste ejemplo es equivalente al anterior, pero utiliza una función lambda para calcular el cuadrado de cada número.\n\n## MULTIPLES ITERABLES\n\n`map()` puede tomar múltiples iterables como argumentos. En este caso, la función debe aceptar tantos argumentos como iterables se proporcionen.\n\n```python\nnumeros1 = [1, 2, 3]\r\nnumeros2 = [4, 5, 6]\r\n\r\nresultados = map(lambda x, y: x + y, numeros1, numeros2)\r\n\r\nprint(list(resultados))  # Output: [5, 7, 9]\n```\n\nAquí, la función lambda suma los elementos correspondientes de numeros1 y numeros2.\n\n`filter()`\n\nLa función `filter()` toma dos argumentos: una función y un iterable. Aplica la función a cada elemento del iterable y devuelve un iterador con los elementos para los cuales la función devuelve `True`.\n\n### SINTAXIS\n\n```python\nfilter(function, iterable)\n```\n\n* **function**: Una función que devuelve True o False.\n\n* **iterable**: El iterable que se va a filtrar.\n\n### EJEMPLO DE IMPLEMENTACION\n\n```python\ndef es_par(x):\r\n    return x % 2 == 0\r\n\r\nnumeros = [1, 2, 3, 4, 5, 6]\r\nresultados = filter(es_par, numeros)\r\n\r\nprint(list(resultados))  # Output: [2, 4, 6]\n```\n\nEn este ejemplo, la función `es_par` verifica si un número es par. La función `filter()` devuelve un iterador con los números pares de la lista numeros.\n\n### USO CON FUNCIONES LAMBDA\n\nAl igual que con `map()`, las funciones lambda son útiles con `filter()` para operaciones simples.\n\n```python\nnumeros = [1, 2, 3, 4, 5, 6]\r\nresultados = filter(lambda x: x % 2 == 0, numeros)\r\n\r\nprint(list(resultados))  # Output: [2, 4, 6]\n```\n\nEste ejemplo es equivalente al anterior, pero utiliza una función lambda para verificar si un número es par.\n\n## reduce()\n\nLa función `reduce()` aplica una función de dos argumentos acumulativamente a los elementos de un iterable, reduciéndolo a un solo valor. A diferencia de `map()` y `filter()`, `reduce()` no es una función incorporada en Python 3 y debe importarse desde el módulo `functools`.\n\n### SINTAXIS reduce()\n\n```python\nfrom functools import reduce\r\n\r\nreduce(function, iterable[, initializer])\n```\n\n* **function**: Una función que toma dos argumentos y devuelve un valor.\n\n* **iterable**: El iterable que se va a reducir.\n\n* **initializer (opcional)**: Un valor inicial que se utiliza como primer argumento en la primera llamada a la función.\n\n### EJEMPLO DE IMPLEMENTACION reduce()\n\n```python\nfrom functools import reduce\r\n\r\ndef multiplicar(x, y):\r\n    return x * y\r\n\r\nnumeros = [1, 2, 3, 4, 5]\r\nresultado = reduce(multiplicar, numeros)\r\n\r\nprint(resultado)  # Output: 120\n```\n\nEn este ejemplo, la función `multiplicar` multiplica dos números. La función `reduce()` aplica esta función acumulativamente a los elementos de la lista `numeros`, resultando en el producto de todos los números.\n\n### USO CON FUNCIONES LAMBDA reduce()\n\nAl igual que con map() y filter(), las funciones lambda son útiles con reduce() para operaciones simples.\n\n```python\nfrom functools import reduce\r\n\r\nnumeros = [1, 2, 3, 4, 5]\r\nresultado = reduce(lambda x, y: x * y, numeros)\r\n\r\nprint(resultado)  # Output: 120\n```\n\nEste ejemplo es equivalente al anterior, pero utiliza una función lambda para multiplicar los números.\n\n### INICIALIZADOR\n\nEl argumento `initializer` se utiliza como valor inicial. Si se proporciona, se utiliza como el primer argumento en la primera llamada a la función.\n\n```python\nfrom functools import reduce\r\n\r\nnumeros = [1, 2, 3, 4, 5]\r\nresultado = reduce(lambda x, y: x * y, numeros, 10)\r\n\r\nprint(resultado)  # Output: 1200\n```\n\nEn este ejemplo, el valor inicial es 10, por lo que el resultado es 10 multiplicado por el producto de todos los números en la lista.\n\n## ALTERNATIVAS MODERNAS\n\nEn Python 3, las funciones `map()` y `filter()` devuelven iteradores en lugar de listas, lo que puede ser más eficiente en términos de memoria. Sin embargo, a menudo se utilizan comprensiones de lista y expresiones generadoras como alternativas más legibles y Pythonicas.\n\n### COMPRESIONES DE LISTA\n\nLas comprensiones de lista ofrecen una sintaxis concisa para crear listas basadas en iterables existentes.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\r\nresultados = [x * x para x in numeros]\r\n\r\nprint(resultados)  # Output: [1, 4, 9, 16, 25]\n```\n\nEste ejemplo es equivalente al uso de map() con una función lambda para calcular el cuadrado de cada número.\n\n### EXPRESIONES GENERADORAS\n\nLas expresiones generadoras son similares a las comprensiones de lista, pero devuelven un iterador en lugar de una lista. Son útiles para trabajar con grandes cantidades de datos, ya que no almacenan todos los resultados en la memoria a la vez.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\r\nresultados = (x * x para x in numeros)\r\n\r\nprint(list(resultados))  # Output: [1, 4, 9, 16, 25]\n```\n\nEste ejemplo es equivalente al uso de `map()` con una función lambda para calcular el cuadrado de cada número, pero devuelve un iterador en lugar de una lista.\n\n## ALTERNATIVA A filter()\n\nLas comprensiones de lista y las expresiones generadoras también se pueden utilizar como alternativas a `filter()`.\n\n```python\nnumeros = [1, 2, 3, 4, 5, 6]\r\nresultados = [x para x in numeros if x % 2 == 0]\r\n\r\nprint(resultados)  # Output: [2, 4, 6]\n```\n\nEste ejemplo es equivalente al uso de `filter()` con una función lambda para filtrar los números pares.\n\n## ALTERNATIVA A reduce()\n\nPara `reduce()`, no hay una alternativa tan directa en Python moderno, pero se puede lograr el mismo resultado utilizando un bucle `for` o una función acumuladora.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\r\nresultado = 1\r\nfor x in numeros:\r\n    resultado *= x\r\n\r\nprint(resultado)  # Output: 120\n```\n\nEste ejemplo es equivalente al uso de `reduce()` con una función lambda para multiplicar todos los números en la lista.\n\n## CONSIDERACIONES IMPORTANTES\n\n* **Legibilidad**: Aunque `map()`, `filter()` y `reduce()` pueden ser concisas, a veces las comprensiones de lista y las expresiones generadoras son más legibles, especialmente para operaciones complejas.\n\n* **Eficiencia**: En Python 3, `map()` y `filter()` devuelven iteradores, lo que puede ser más eficiente en términos de memoria que las listas. Sin embargo, las comprensiones de lista y las expresiones generadoras a menudo son más rápidas.\n\n* **reduce()**: Debido a su eliminación de las funciones incorporadas, se recomienda usar alternativas más explícitas como bucles `for` para mejorar la legibilidad.\n\n## EJEMPLOS ADICIONALES\n\n### EJEMPLO 1: CONVERTIR UNA LISTA DE STRING A ENTEROS\n\n```python\nstrings = [\"1\", \"2\", \"3\", \"4\", \"5\"]\r\nenteros = list(map(int, strings))\r\n\r\nprint(enteros)  # Output: [1, 2, 3, 4, 5]\n```\n\n### EJEMPLO 2: FILTRAR PALABRAS QUE COMIENZAN CON UNA VOCAL\n\n```python\npalabras = [\"manzana\", \"banana\", \"uva\", \"pera\", \"kiwi\"]\r\nvocales = [\"a\", \"e\", \"i\", \"o\", \"u\"]\r\nresultados = list(filter(lambda x: x[0].lower() in vocales, palabras))\r\n\r\nprint(resultados)  # Output: ['manzana', 'uva']\n```\n\n### EJEMPLO 3: CALCULAR LA SUMA DE LOS CUADRADOS DE UNA LISTA\n\n```python\nfrom functools import reduce\r\n\r\nnumeros = [1, 2, 3, 4, 5]\r\nresultado = reduce(lambda x, y: x + y**2, numeros, 0)\r\n\r\nprint(resultado)  # Output: 55 (0 + 1 + 4 + 9 + 16 + 25)\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types/numeric-operations",
    "title": "Operaciones con tipos numéricos en Python",
    "description": "Guía detallada sobre las operaciones aritméticas, funciones y bibliotecas para trabajar con números en Python.",
    "content": "Python ofrece una amplia gama de herramientas para realizar operaciones con tipos numéricos, que incluyen enteros (`int`), números de punto flotante (`float`) y números complejos (`complex`). Este documento explora las operaciones aritméticas básicas, las funciones integradas y las bibliotecas que facilitan el trabajo con números en Python.\n\n## OPERACIONES ARITMETICAS BASICAS\n\nPython soporta las operaciones aritméticas básicas utilizando los siguientes operadores:\n\n* **Suma (+):** Suma dos números.\n\n* **Resta (-):** Resta dos números.\n\n* **Multiplicación (\\*):** Multiplica dos números.\n\n* **División (/):** Divide dos números y devuelve un número de punto flotante.\n\n* **División Entera (//):** Divide dos números y devuelve la parte entera del cociente.\n\n* **Módulo (%):** Devuelve el resto de la división entre dos números.\n\n* **Potenciación (\\*\\*):** Eleva un número a la potencia de otro.\n\n```python\na = 10\r\nb = 3\r\n\r\nsuma = a + b                # Resultado: 13\r\nresta = a - b               # Resultado: 7\r\nmultiplicacion = a * b      # Resultado: 30\r\ndivision = a / b            # Resultado: 3.333...\r\ndivision_entera = a // b    # Resultado: 3\r\nmodulo = a % b              # Resultado: 1\r\npotencia = a ** b           # Resultado: 1000\r\n\r\nprint(f\"Suma: {suma}, Resta: {resta}, Multiplicación: {multiplicacion}\")\r\nprint(f\"División: {division}, División Entera: {division_entera}, Módulo: {modulo}, Potencia: {potencia}\")\n```\n\n## FUNCIONES INTEGRADAS PARA OPERACIONES NUMERICAS\n\nPython ofrece varias funciones integradas que facilitan las operaciones numéricas:\n\n* **abs(x)**: Devuelve el valor absoluto de x.\n\n* **round(x, n)**: Redondea x a n decimales.\n\n* **pow(x, y)**: Eleva x a la potencia de y (equivalente a x \\*\\* y).\n\n* **min(a, b, ...)**: Devuelve el valor mínimo entre los argumentos.\n\n* **max(a, b, ...)**: Devuelve el valor máximo entre los argumentos.\n\n```python\nx = -5.7\r\ny = 3.14159\r\n\r\nvalor_absoluto = abs(x)     # Resultado: 5.7\r\nredondeo = round(y, 2)      # Resultado: 3.14\r\npotencia = pow(2, 3)        # Resultado: 8\r\nminimo = min(1, 2, 3, 4)    # Resultado: 1\r\nmaximo = max(1, 2, 3, 4)    # Resultado: 4\r\n\r\nprint(f\"Valor Absoluto: {valor_absoluto}, Redondeo: {redondeo}, Potencia: {potencia}\")\r\nprint(f\"Mínimo: {minimo}, Máximo: {maximo}\")\n```\n\n## BIBLIOTECA math\n\nLa biblioteca math proporciona funciones matemáticas más avanzadas:\n\n* **math.sqrt(x)**: Devuelve la raíz cuadrada de x.\n\n* **math.ceil(x)**: Redondea x al entero superior más cercano.\n\n* **math.floor(x)**: Redondea x al entero inferior más cercano.\n\n* **math.sin(x)**: Devuelve el seno de x (en radianes).\n\n* **math.cos(x)**: Devuelve el coseno de x (en radianes).\n\n* **math.tan(x)**: Devuelve la tangente de x (en radianes).\n\n* **math.log(x, base)**: Devuelve el logaritmo de x en la base especificada.\n\n* **math.pi**: Constante que representa el valor de π (pi).\n\n* **math.e**: Constante que representa el número de Euler.\n\n```python\nimport math\r\n\r\nx = 16\r\ny = 5.7\r\n\r\nraiz_cuadrada = math.sqrt(x)   # Resultado: 4.0\r\nceil = math.ceil(y)           # Resultado: 6\r\nfloor = math.floor(y)          # Resultado: 5\r\nseno = math.sin(math.pi / 2)  # Resultado: 1.0\r\nlogaritmo = math.log(10, 10)   # Resultado: 1.0\r\n\r\nprint(f\"Raíz Cuadrada: {raiz_cuadrada}, Ceil: {ceil}, Floor: {floor}\")\r\nprint(f\"Seno (π/2): {seno}, Logaritmo (10 en base 10): {logaritmo}\")\r\nprint(f\"Valor de Pi: {math.pi}, Valor de e: {math.e}\")\n```\n\n## BIBLIOTECA cmath PARA NUMEROS COMPLEJOS\n\nPara trabajar con números complejos, Python ofrece la biblioteca cmath:\n\n* **cmath.sqrt(x)**: Devuelve la raíz cuadrada de un número complejo.\n\n* **cmath.phase(x)**: Devuelve la fase de un número complejo.\n\n* **cmath.polar(x)**: Convierte un número complejo a coordenadas polares.\n\n* **cmath.rect(r, phi)**: Convierte coordenadas polares a un número complejo.\n\n```python\nimport cmath\r\n\r\nz = complex(3, -4)\r\n\r\nraiz_cuadrada = cmath.sqrt(z)  # Resultado: (2-1j)\r\nfase = cmath.phase(z)         # Resultado: -0.927...\r\npolar = cmath.polar(z)        # Resultado: (5.0, -0.927...)\r\nrect = cmath.rect(5, 0)       # Resultado: (5+0j)\r\n\r\nprint(f\"Raíz Cuadrada: {raiz_cuadrada}, Fase: {fase}, Polar: {polar}, Rect: {rect}\")\n```\n\n## FORMATEO DE NUMEROS\n\nPython permite formatear números para controlar la precisión y la representación:\n\n* **f-strings**: Permiten insertar variables directamente en cadenas de texto.\n\n* **format()**: Método para formatear cadenas.\n\n```python\nnumero = 1234.56789\r\n\r\n# Usando f-strings\r\nprint(f\"Número con dos decimales: {numero:.2f}\")       # Resultado: 1234.57\r\nprint(f\"Número con separador de miles: {numero:,.2f}\")  # Resultado: 1,234.57\r\n\r\n# Usando format()\r\nprint(\"Número con dos decimales: {:.2f}\".format(numero))       # Resultado: 1234.57\r\nprint(\"Número con separador de miles: {:,.2f}\".format(numero))  # Resultado: 1,234.57\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types/set-operations",
    "title": "Operaciones con Conjuntos en Python",
    "description": "Explora las operaciones fundamentales que puedes realizar con conjuntos (sets) en Python, incluyendo unión, intersección, diferencia y diferencia simétrica.",
    "content": "Los conjuntos en Python son colecciones desordenadas de elementos únicos. Son una herramienta poderosa para realizar operaciones matemáticas de conjuntos, como unión, intersección y diferencia. En esta documentación, exploraremos cómo realizar estas operaciones utilizando Python.\n\n## ¿QUE SON LOS CONJUNTOS?\n\nUn conjunto es una colección no ordenada de elementos únicos. Esto significa que un conjunto no puede contener duplicados. Los conjuntos son útiles para eliminar duplicados de una lista y para realizar operaciones matemáticas de conjuntos.\n\nEn Python, los conjuntos se crean utilizando la función `set()` o utilizando llaves `{}`.\n\n```python\n# Creación de un conjunto utilizando la función set()\r\nmi_conjunto = set([1, 2, 3, 4, 5])\r\nprint(mi_conjunto)  # Output: {1, 2, 3, 4, 5}\r\n\r\n# Creación de un conjunto utilizando llaves {}\r\notro_conjunto = {3, 4, 5, 6, 7}\r\nprint(otro_conjunto)  # Output: {3, 4, 5, 6, 7}\n```\n\n## OPERACIONES BASICAS CON CONJUNTOS\n\nPython proporciona varios métodos para realizar operaciones con conjuntos. Aquí están las operaciones más comunes:\n\n### 1. UNION\n\nLa unión de dos conjuntos contiene todos los elementos de ambos conjuntos.\n\n* **Método**: `union()` o el operador `|`\n\n```python\nconjunto_a = {1, 2, 3}\r\nconjunto_b = {3, 4, 5}\r\n\r\n# Usando el método union()\r\nunion_conjunto = conjunto_a.union(conjunto_b)\r\nprint(union_conjunto)  # Output: {1, 2, 3, 4, 5}\r\n\r\n# Usando el operador |\r\nunion_conjunto_operador = conjunto_a | conjunto_b\r\nprint(union_conjunto_operador)  # Output: {1, 2, 3, 4, 5}\n```\n\n### 2. ITERSECCION\n\nLa intersección de dos conjuntos contiene solo los elementos que están presentes en ambos conjuntos.\n\n* **Método**: `intersection()` o el operador `&`\n\n```python\nconjunto_a = {1, 2, 3}\r\nconjunto_b = {3, 4, 5}\r\n\r\n# Usando el método intersection()\r\ninterseccion_conjunto = conjunto_a.intersection(conjunto_b)\r\nprint(interseccion_conjunto)  # Output: {3}\r\n\r\n# Usando el operador &\r\ninterseccion_conjunto_operador = conjunto_a & conjunto_b\r\nprint(interseccion_conjunto_operador)  # Output: {3}\n```\n\n### 3. DIFERENCIA\n\nLa diferencia entre dos conjuntos contiene los elementos que están en el primer conjunto pero no en el segundo.\n\n* **Método**: `difference()` o el operador `-`\n\n```python\nconjunto_a = {1, 2, 3}\r\nconjunto_b = {3, 4, 5}\r\n\r\n# Usando el método difference()\r\ndiferencia_conjunto = conjunto_a.difference(conjunto_b)\r\nprint(diferencia_conjunto)  # Output: {1, 2}\r\n\r\n# Usando el operador -\r\ndiferencia_conjunto_operador = conjunto_a - conjunto_b\r\nprint(diferencia_conjunto_operador)  # Output: {1, 2}\n```\n\n### 4. DIFERENCIA SIMETRICA\n\nLa diferencia simétrica entre dos conjuntos contiene los elementos que están en uno u otro conjunto, pero no en ambos.\n\n* **Método**: `symmetric_difference()` o el operador `^`\n\n```python\nconjunto_a = {1, 2, 3}\r\nconjunto_b = {3, 4, 5}\r\n\r\n# Usando el método symmetric_difference()\r\ndiferencia_simetrica_conjunto = conjunto_a.symmetric_difference(conjunto_b)\r\nprint(diferencia_simetrica_conjunto)  # Output: {1, 2, 4, 5}\r\n\r\n# Usando el operador ^\r\ndiferencia_simetrica_conjunto_operador = conjunto_a ^ conjunto_b\r\nprint(diferencia_simetrica_conjunto_operador)  # Output: {1, 2, 4, 5}\n```\n\n## OTROS METODOS UTILES\n\n* **add(elemento)**: Añade un elemento al conjunto.\n\n* **remove(elemento)**: Elimina un elemento del conjunto. Lanza un error si el elemento no está presente.\n\n* **discard(elemento)**: Elimina un elemento del conjunto si está presente. No lanza un error si el elemento no está presente.\n\n* **pop()**: Elimina y retorna un elemento arbitrario del conjunto.\n\n* **clear()**: Elimina todos los elementos del conjunto.\n\n```python\nconjunto = {1, 2, 3}\r\n\r\nconjunto.add(4)\r\nprint(conjunto)  # Output: {1, 2, 3, 4}\r\n\r\nconjunto.remove(2)\r\nprint(conjunto)  # Output: {1, 3, 4}\r\n\r\nconjunto.discard(5)  # No hace nada porque 5 no está en el conjunto\r\nprint(conjunto)  # Output: {1, 3, 4}\r\n\r\nelemento_eliminado = conjunto.pop()\r\nprint(elemento_eliminado)  # Output: (puede ser 1, 3 o 4)\r\nprint(conjunto)  # Output: (dependiendo del elemento eliminado)\r\n\r\nconjunto.clear()\r\nprint(conjunto)  # Output: set()\n```\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO 1: ENCONTRAR ELEMENTOS UNICOS EN UNA LISTA\n\n```python\nlista_con_duplicados = [1, 2, 2, 3, 4, 4, 5]\r\nelementos_unicos = set(lista_con_duplicados)\r\nprint(elementos_unicos)  # Output: {1, 2, 3, 4, 5}\n```\n\n### EJEMPLO 2: COMPARAR ELEMENTOS ENTRE DOS LISTAS\n\n```python\nlista_a = [1, 2, 3, 4, 5]\r\nlista_b = [3, 4, 5, 6, 7]\r\n\r\nconjunto_a = set(lista_a)\r\nconjunto_b = set(lista_b)\r\n\r\n# Elementos en lista_a pero no en lista_b\r\ndiferencia = conjunto_a - conjunto_b\r\nprint(diferencia)  # Output: {1, 2}\r\n\r\n# Elementos comunes en ambas listas\r\ninterseccion = conjunto_a & conjunto_b\r\nprint(interseccion)  # Output: {3, 4, 5}\n```\n"
  },
  {
    "slug": "/programming/languages/python/data-types/string-methods",
    "title": "Métodos de Cadenas en Python",
    "description": "Exploración exhaustiva de los métodos de cadenas en Python, incluyendo manipulación, búsqueda, validación y formateo.",
    "content": "Las cadenas son uno de los tipos de datos más fundamentales en Python, utilizadas para representar texto. Python ofrece una rica variedad de métodos integrados para manipular y trabajar con cadenas de manera eficiente. Este documento explora en detalle estos métodos, proporcionando ejemplos y casos de uso para cada uno.\n\n### OBJETIVOS CLAVE\n\n1. **Manipulación de Cadenas:** Aprender a modificar cadenas, como cambiar mayúsculas/minúsculas, eliminar espacios en blanco y dividir/unir cadenas.\n2. **Búsqueda y Reemplazo:** Dominar las técnicas para buscar subcadenas dentro de una cadena y reemplazarlas.\n3. **Validación de Cadenas:** Utilizar métodos para verificar si una cadena cumple con ciertos criterios, como ser numérica, alfabética o contener solo espacios en blanco.\n4. **Formateo de Cadenas:** Explorar las diferentes formas de formatear cadenas para insertar valores y crear salidas personalizadas.\n\n### METODOS DE MANIPULACION DE CADENAS\n\n* **`lower()`:** Convierte todos los caracteres de una cadena a minúsculas.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  texto_minusculas = texto.lower()\r\n  print(texto_minusculas)  # Output: hola mundo\n  ```\n* **`upper()`:** Convierte todos los caracteres de una cadena a mayúsculas.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  texto_mayusculas = texto.upper()\r\n  print(texto_mayusculas)  # Output: HOLA MUNDO\n  ```\n* **`capitalize()`:** Convierte el primer carácter de una cadena a mayúscula y el resto a minúsculas.\n\n  ```python\n  texto = \"hola mundo\"\r\n  texto_capitalizado = texto.capitalize()\r\n  print(texto_capitalizado)  # Output: Hola mundo\n  ```\n* **`title()`:** Convierte el primer carácter de cada palabra en una cadena a mayúscula.\n\n  ```python\n  texto = \"hola mundo\"\r\n  texto_titulo = texto.title()\r\n  print(texto_titulo)  # Output: Hola Mundo\n  ```\n* **`swapcase()`:** Invierte las mayúsculas y minúsculas en una cadena.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  texto_invertido = texto.swapcase()\r\n  print(texto_invertido)  # Output: hOLA mUNDO\n  ```\n* **`strip()`:** Elimina los espacios en blanco al principio y al final de una cadena.\n\n  ```python\n  texto = \"   Hola Mundo   \"\r\n  texto_sin_espacios = texto.strip()\r\n  print(texto_sin_espacios)  # Output: Hola Mundo\n  ```\n* **`lstrip()`:** Elimina los espacios en blanco al principio de una cadena.\n\n  ```python\n  texto = \"   Hola Mundo   \"\r\n  texto_sin_espacios_izquierda = texto.lstrip()\r\n  print(texto_sin_espacios_izquierda)  # Output: Hola Mundo\n  ```\n* **`rstrip()`:** Elimina los espacios en blanco al final de una cadena.\n\n  ```python\n  texto = \"   Hola Mundo   \"\r\n  texto_sin_espacios_derecha = texto.rstrip()\r\n  print(texto_sin_espacios_derecha)  # Output:   Hola Mundo\n  ```\n* **`removeprefix(prefix)` (Python 3.9+):** Elimina un prefijo específico de una cadena si está presente.\n\n  ```python\n  texto = \"PrefijoHola Mundo\"\r\n  texto_sin_prefijo = texto.removeprefix(\"Prefijo\")\r\n  print(texto_sin_prefijo)  # Output: Hola Mundo\n  ```\n* **`removesuffix(suffix)` (Python 3.9+):** Elimina un sufijo específico de una cadena si está presente.\n\n  ```python\n  texto = \"Hola MundoSufijo\"\r\n  texto_sin_sufijo = texto.removesuffix(\"Sufijo\")\r\n  print(texto_sin_sufijo)  # Output: Hola Mundo\n  ```\n\n### METODOS DE BUSQUEDA Y REEMPLAZO\n\n* **`find(subcadena, inicio, fin)`:** Busca la primera ocurrencia de una subcadena dentro de una cadena y devuelve su índice. Devuelve -1 si no se encuentra. Los argumentos `inicio` y `fin` son opcionales y especifican el rango de búsqueda.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  indice = texto.find(\"Hola\")\r\n  print(indice)  # Output: 0\r\n  indice2 = texto.find(\"Hola\", 1)\r\n  print(indice2) # Output: 12\n  ```\n* **`rfind(subcadena, inicio, fin)`:** Busca la última ocurrencia de una subcadena dentro de una cadena y devuelve su índice. Devuelve -1 si no se encuentra.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  indice = texto.rfind(\"Hola\")\r\n  print(indice)  # Output: 12\n  ```\n* **`index(subcadena, inicio, fin)`:** Similar a `find()`, pero lanza una excepción `ValueError` si la subcadena no se encuentra.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  indice = texto.index(\"Mundo\")\r\n  print(indice)  # Output: 5\n  ```\n* **`rindex(subcadena, inicio, fin)`:** Similar a `rfind()`, pero lanza una excepción `ValueError` si la subcadena no se encuentra.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  indice = texto.rindex(\"Hola\")\r\n  print(indice)  # Output: 12\n  ```\n* **`startswith(prefijo, inicio, fin)`:** Verifica si una cadena comienza con un prefijo específico.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  comienza_con_hola = texto.startswith(\"Hola\")\r\n  print(comienza_con_hola)  # Output: True\n  ```\n* **`endswith(sufijo, inicio, fin)`:** Verifica si una cadena termina con un sufijo específico.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  termina_con_mundo = texto.endswith(\"Mundo\")\r\n  print(termina_con_mundo)  # Output: True\n  ```\n* **`replace(viejo, nuevo, conteo)`:** Reemplaza todas las ocurrencias de una subcadena con otra. El argumento `conteo` es opcional y especifica el número máximo de reemplazos a realizar.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  nuevo_texto = texto.replace(\"Hola\", \"Adiós\")\r\n  print(nuevo_texto)  # Output: Adiós Mundo, Adiós Python\n  ```\n* **`count(subcadena, inicio, fin)`:** Cuenta el número de ocurrencias de una subcadena dentro de una cadena.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  conteo = texto.count(\"Hola\")\r\n  print(conteo)  # Output: 2\n  ```\n\n### METODOS DE VALIDACION DE CADENAS\n\n* **`isalnum()`:** Devuelve `True` si todos los caracteres de la cadena son alfanuméricos (letras o números) y la cadena no está vacía.\n\n  ```python\n  texto1 = \"HolaMundo123\"\r\n  texto2 = \"Hola Mundo\"\r\n  print(texto1.isalnum())  # Output: True\r\n  print(texto2.isalnum())  # Output: False\n  ```\n* **`isalpha()`:** Devuelve `True` si todos los caracteres de la cadena son letras y la cadena no está vacía.\n\n  ```python\n  texto1 = \"HolaMundo\"\r\n  texto2 = \"Hola Mundo123\"\r\n  print(texto1.isalpha())  # Output: True\r\n  print(texto2.isalpha())  # Output: False\n  ```\n* **`isdigit()`:** Devuelve `True` si todos los caracteres de la cadena son dígitos y la cadena no está vacía.\n\n  ```python\n  texto1 = \"12345\"\r\n  texto2 = \"123Hola\"\r\n  print(texto1.isdigit())  # Output: True\r\n  print(texto2.isdigit())  # Output: False\n  ```\n* **`isnumeric()`:** Devuelve `True` si todos los caracteres de la cadena son caracteres numéricos y la cadena no está vacía. Similar a `isdigit()`, pero también incluye caracteres Unicode que representan números.\n\n  ```python\n  texto1 = \"12345\"\r\n  texto2 = \"½\"\r\n  print(texto1.isnumeric())  # Output: True\r\n  print(texto2.isnumeric())  # Output: True\n  ```\n* **`isdecimal()`:** Devuelve `True` si todos los caracteres de la cadena son caracteres decimales y la cadena no está vacía. Más restrictivo que `isnumeric()`.\n\n  ```python\n  texto1 = \"12345\"\r\n  texto2 = \"½\"\r\n  print(texto1.isdecimal())  # Output: True\r\n  print(texto2.isdecimal())  # Output: False\n  ```\n* **`isspace()`:** Devuelve `True` si todos los caracteres de la cadena son espacios en blanco y la cadena no está vacía.\n\n  ```python\n  texto1 = \"   \"\r\n  texto2 = \" Hola \"\r\n  print(texto1.isspace())  # Output: True\r\n  print(texto2.isspace())  # Output: False\n  ```\n* **`islower()`:** Devuelve `True` si todos los caracteres de la cadena están en minúsculas y hay al menos un carácter en minúscula.\n\n  ```python\n  texto1 = \"hola mundo\"\r\n  texto2 = \"Hola Mundo\"\r\n  print(texto1.islower())  # Output: True\r\n  print(texto2.islower())  # Output: False\n  ```\n* **`isupper()`:** Devuelve `True` si todos los caracteres de la cadena están en mayúsculas y hay al menos un carácter en mayúscula.\n\n  ```python\n  texto1 = \"HOLA MUNDO\"\r\n  texto2 = \"Hola Mundo\"\r\n  print(texto1.isupper())  # Output: True\r\n  print(texto2.isupper())  # Output: False\n  ```\n* **`istitle()`:** Devuelve `True` si la cadena está en formato de título (la primera letra de cada palabra en mayúscula).\n\n  ```python\n  texto1 = \"Hola Mundo\"\r\n  texto2 = \"hola mundo\"\r\n  print(texto1.istitle())  # Output: True\r\n  print(texto2.istitle())  # Output: False\n  ```\n* **`isidentifier()`:** Devuelve `True` si la cadena es un identificador válido en Python.\n\n  ```python\n  texto1 = \"variable_valida\"\r\n  texto2 = \"1variable\"\r\n  print(texto1.isidentifier())  # Output: True\r\n  print(texto2.isidentifier())  # Output: False\n  ```\n* **`isprintable()`:** Devuelve `True` si todos los caracteres de la cadena son imprimibles (no son caracteres de control).\n\n  ```python\n  texto1 = \"Hola Mundo\"\r\n  texto2 = \"Hola\\nMundo\"\r\n  print(texto1.isprintable())  # Output: True\r\n  print(texto2.isprintable())  # Output: False\n  ```\n\n### METODOS DE FORMATO DE CADENAS\n\n* **`format(*args, **kwargs)`:** Permite insertar valores en una cadena utilizando marcadores de posición.\n\n  ```python\n  nombre = \"Juan\"\r\n  edad = 30\r\n  texto = \"Me llamo {} y tengo {} años.\".format(nombre, edad)\r\n  print(texto)  # Output: Me llamo Juan y tengo 30 años.\n  ```\n\n  También se pueden usar nombres para los marcadores de posición:\n\n  ```python\n  nombre = \"Juan\"\r\n  edad = 30\r\n  texto = \"Me llamo {nombre} y tengo {edad} años.\".format(nombre=nombre, edad=edad)\r\n  print(texto)  # Output: Me llamo Juan y tengo 30 años.\n  ```\n\n* **`f-strings` (Python 3.6+):** Una forma más concisa y legible de formatear cadenas.\n\n  ```python\n  nombre = \"Juan\"\r\n  edad = 30\r\n  texto = f\"Me llamo {nombre} y tengo {edad} años.\"\r\n  print(texto)  # Output: Me llamo Juan y tengo 30 años.\n  ```\n\n* **`%`-formatting (estilo antiguo):** Aunque menos común en el código moderno, todavía se puede encontrar.\n\n  ```python\n  nombre = \"Juan\"\r\n  edad = 30\r\n  texto = \"Me llamo %s y tengo %d años.\" % (nombre, edad)\r\n  print(texto)  # Output: Me llamo Juan y tengo 30 años.\n  ```\n\n### METODOS DE DIVISION Y UNION DE CADENAS\n\n* **`split(separador, maxsplit)`:** Divide una cadena en una lista de subcadenas, utilizando un separador específico. El argumento `maxsplit` es opcional y especifica el número máximo de divisiones a realizar.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  lista = texto.split(\", \")\r\n  print(lista)  # Output: ['Hola Mundo', 'Hola Python']\n  ```\n* **`rsplit(separador, maxsplit)`:** Similar a `split()`, pero comienza a dividir desde el final de la cadena.\n\n  ```python\n  texto = \"Hola Mundo, Hola Python\"\r\n  lista = texto.rsplit(\", \", 1)\r\n  print(lista)  # Output: ['Hola Mundo', 'Hola Python']\n  ```\n* **`splitlines(keepends)`:** Divide una cadena en una lista de líneas, utilizando los caracteres de nueva línea como separadores. El argumento `keepends` es opcional y especifica si se deben mantener los caracteres de nueva línea en las líneas resultantes.\n\n  ```python\n  texto = \"Hola Mundo\\nHola Python\"\r\n  lista = texto.splitlines()\r\n  print(lista)  # Output: ['Hola Mundo', 'Hola Python']\n  ```\n* **`join(iterable)`:** Une una lista de cadenas en una sola cadena, utilizando la cadena como separador.\n\n  ```python\n  lista = [\"Hola\", \"Mundo\", \"Python\"]\r\n  texto = \" \".join(lista)\r\n  print(texto)  # Output: Hola Mundo Python\n  ```\n\n### OTROS METODOS UTILES\n\n* **`zfill(ancho)`:** Rellena una cadena con ceros a la izquierda hasta alcanzar un ancho específico.\n\n  ```python\n  numero = \"123\"\r\n  numero_rellenado = numero.zfill(5)\r\n  print(numero_rellenado)  # Output: 00123\n  ```\n* **`center(ancho, caracter_de_relleno)`:** Centra una cadena dentro de un ancho específico, rellenando los espacios restantes con un carácter de relleno.\n\n  ```python\n  texto = \"Hola\"\r\n  texto_centrado = texto.center(10, \"*\")\r\n  print(texto_centrado)  # Output: ***Hola***\n  ```\n* **`ljust(ancho, caracter_de_relleno)`:** Justifica una cadena a la izquierda dentro de un ancho específico, rellenando los espacios restantes con un carácter de relleno.\n\n  ```python\n  texto = \"Hola\"\r\n  texto_justificado_izquierda = texto.ljust(10, \"*\")\r\n  print(texto_justificado_izquierda)  # Output: Hola******\n  ```\n* **`rjust(ancho, caracter_de_relleno)`:** Justifica una cadena a la derecha dentro de un ancho específico, rellenando los espacios restantes con un carácter de relleno.\n\n  ```python\n  texto = \"Hola\"\r\n  texto_justificado_derecha = texto.rjust(10, \"*\")\r\n  print(texto_justificado_derecha)  # Output: ******Hola\n  ```\n* **`encode(encoding='utf-8', errors='strict')`:** Codifica una cadena en una secuencia de bytes utilizando una codificación específica.\n\n  ```python\n  texto = \"Hola Mundo\"\r\n  bytes_codificados = texto.encode('utf-8')\r\n  print(bytes_codificados)  # Output: b'Hola Mundo'\n  ```\n* **`expandtabs(tabsize=8)`:** Reemplaza los caracteres de tabulación en una cadena con un número específico de espacios.\n\n  ```python\n  texto = \"Hola\\tMundo\"\r\n  texto_sin_tabs = texto.expandtabs(4)\r\n  print(texto_sin_tabs)  # Output: Hola    Mundo\n  ```\n\n### EJEMPLOS DE IMPLEMENTACION\n\n#### EJEMPLO 1: LIMPIEZA DE DATOS\n\n```python\ndatos = \"   Nombre:  Juan Pérez  ,  Edad: 30  \"\r\ndatos_limpios = datos.strip().replace(\"Nombre:\", \"\").replace(\"Edad:\", \"\").split(\",\")\r\nnombre = datos_limpios[0].strip()\r\nedad = datos_limpios[1].strip()\r\nprint(f\"Nombre: {nombre}, Edad: {edad}\")\n```\n\n#### EJEMPLO 2: VALIDACION DE ENTRADA DE USUARIO\n\n```python\ndef validar_email(email):\r\n    if \"@\" in email and \".\" in email:\r\n        return True\r\n    else:\r\n        return False\r\n\r\nemail = input(\"Ingrese su email: \")\r\nif validar_email(email):\r\n    print(\"Email válido\")\r\nelse:\r\n    print(\"Email inválido\")\n```\n"
  },
  {
    "slug": "/programming/languages/python/exceptions",
    "title": "Manejo de Excepciones en Python",
    "description": "Aprende a manejar excepciones en Python para escribir código robusto y a prueba de errores.",
    "content": "El manejo de excepciones es un aspecto crucial en la programación, especialmente en Python, ya que permite crear aplicaciones robustas y tolerantes a fallos. Las excepciones son eventos que interrumpen el flujo normal de un programa, generalmente debido a errores o condiciones inesperadas. Python proporciona mecanismos para capturar y manejar estas excepciones, permitiendo que el programa se recupere o termine de manera controlada.\n\n## ¿QUE SON LAS EXCEPCIONES?\n\nEn Python, una excepción es un objeto que representa un error. Cuando ocurre un error, Python \"lanza\" (o \"levanta\") una excepción. Si la excepción no se maneja, el programa se detiene y muestra un mensaje de error.\n\n### TIPOS COMUNES DE EXCEPCIONES\n\nPython tiene una variedad de excepciones incorporadas, cada una representando un tipo diferente de error. Algunos ejemplos comunes incluyen:\n\n* **TypeError**: Ocurre cuando una operación o función se aplica a un objeto de tipo inapropiado.\n* **ValueError**: Ocurre cuando una función recibe un argumento del tipo correcto, pero con un valor inapropiado.\n* **IndexError**: Ocurre cuando se intenta acceder a un índice fuera de rango en una secuencia (lista, tupla, etc.).\n* **KeyError**: Ocurre cuando se intenta acceder a una clave que no existe en un diccionario.\n* **FileNotFoundError**: Ocurre cuando se intenta abrir un archivo que no existe.\n* **IOError**: Ocurre cuando una operación de entrada/salida falla (por ejemplo, al leer o escribir un archivo).\n* **ZeroDivisionError**: Ocurre cuando se intenta dividir un número por cero.\n* **ImportError**: Ocurre cuando falla la importación de un módulo.\n\n## BLOQUES try, except, finally\n\nPython utiliza los bloques `try`, `except` y `finally` para manejar excepciones.\n\n### EL BLOQUE try\n\nEl bloque `try` contiene el código que podría generar una excepción. Si una excepción ocurre dentro de este bloque, el control se transfiere al bloque `except` correspondiente.\n\n### EL BLOQUE except\n\nEl bloque `except` especifica cómo manejar una excepción particular. Puedes tener múltiples bloques `except` para manejar diferentes tipos de excepciones. Si una excepción ocurre en el bloque `try` y coincide con el tipo especificado en un bloque `except`, el código dentro de ese bloque `except` se ejecuta.\n\n### EL BLOQUE finally\n\nEl bloque `finally` contiene código que siempre se ejecuta, independientemente de si una excepción ocurrió o no. Este bloque es útil para realizar tareas de limpieza, como cerrar archivos o liberar recursos.\n\n### SINTAXIS GENERAL\n\n```python\ntry:\r\n    # Código que podría generar una excepción\r\nexcept TipoDeExcepcion1:\r\n    # Manejo para TipoDeExcepcion1\r\nexcept TipoDeExcepcion2:\r\n    # Manejo para TipoDeExcepcion2\r\nexcept:\r\n    # Manejo para cualquier otra excepción\r\nfinally:\r\n    # Código que siempre se ejecuta\n```\n\n## EJEMPLO DE IMPLEMENTACION\n\n```python\ndef dividir(a, b):\r\n    try:\r\n        resultado = a / b\r\n        print(\"El resultado es:\", resultado)\r\n    except ZeroDivisionError:\r\n        print(\"¡Error! No se puede dividir por cero.\")\r\n    except TypeError:\r\n        print(\"¡Error! Los argumentos deben ser números.\")\r\n    finally:\r\n        print(\"La función dividir ha terminado.\")\r\n\r\n# Ejemplos de uso\r\ndividir(10, 2)\r\ndividir(10, 0)\r\ndividir(10, \"2\")\n```\n\nEn este ejemplo:\n\n* La función `dividir` intenta dividir `a` por `b`.\n\n* Si `b` es cero, se levanta una excepción `ZeroDivisionError`, y el primer bloque `except` la maneja.\n\n* Si `a` o `b` no son números, se levanta una excepción `TypeError`, y el segundo bloque `except` la maneja.\n\n* El bloque `finally` siempre se ejecuta, mostrando un mensaje al final.\n\n### LANZAR EXCEPCIONES (RAISE)\n\nAdemás de manejar excepciones, también puedes lanzar tus propias excepciones usando la palabra clave `raise`. Esto es útil para indicar que algo salió mal en tu código.\n\n```python\ndef validar_edad(edad):\r\n    if edad < 0:\r\n        raise ValueError(\"La edad no puede ser negativa.\")\r\n    if edad > 150:\r\n        raise ValueError(\"La edad no puede ser mayor a 150.\")\r\n    print(\"Edad válida:\", edad)\r\n\r\ntry:\r\n    validar_edad(-10)\r\nexcept ValueError as e:\r\n    print(\"¡Error!\", e)\r\n\r\ntry:\r\n    validar_edad(200)\r\nexcept ValueError as e:\r\n    print(\"¡Error!\", e)\r\n\r\ntry:\r\n    validar_edad(30)\r\nexcept ValueError as e:\r\n    print(\"¡Error!\", e)\n```\n\nEn este ejemplo:\n\n* La función `validar_edad` lanza una excepción `ValueError` si la edad es negativa o mayor a `150`.\n\n* El bloque `try` llama a `validar_edad` y el bloque `except` maneja la excepción `ValueError`, mostrando un mensaje de `error`.\n\n### EXCEPCIONES PERSONALIZADAS\n\nPuedes crear tus propias clases de excepción personalizadas heredando de la clase base `Exception`. Esto te permite definir excepciones específicas para tu aplicación.\n\n```python\nclass MiErrorPersonalizado(Exception):\r\n    def __init__(self, mensaje):\r\n        self.mensaje = mensaje\r\n\r\n    def __str__(self):\r\n        return self.mensaje\r\n\r\ndef procesar_dato(dato):\r\n    if not isinstance(dato, int):\r\n        raise MiErrorPersonalizado(\"El dato debe ser un entero.\")\r\n    print(\"Dato procesado:\", dato)\r\n\r\ntry:\r\n    procesar_dato(\"abc\")\r\nexcept MiErrorPersonalizado as e:\r\n    print(\"¡Error!\", e)\r\n\r\ntry:\r\n    procesar_dato(123)\r\nexcept MiErrorPersonalizado as e:\r\n    print(\"¡Error!\", e)\n```\n\nEn este ejemplo:\n\n* Se define una clase de excepción personalizada `MiErrorPersonalizado` que hereda de `Exception`.\n\n* La función `procesar_dato` lanza una excepción `MiErrorPersonalizado` si el dato no es un entero.\n\n* El bloque `try` llama a `procesar_dato` y el bloque `except` maneja la excepción `MiErrorPersonalizado`, mostrando un mensaje de `error`.\n\n## BUENAS PRACTICAS\n\n* **Sé específico**: Captura solo las excepciones que esperas y puedes manejar. Evita usar bloques except genéricos que capturen todas las excepciones, ya que esto puede ocultar errores inesperados.\n\n* **Usa `finally` para la limpieza**: Asegúrate de liberar recursos en el bloque finally para evitar fugas de memoria o problemas de rendimiento.\n\n* **Documenta tus excepciones**: Explica qué excepciones pueden ser lanzadas por tus funciones y cómo deben ser manejadas.\n\n* **No ignores las excepciones**: Si no puedes manejar una excepción, déjala propagarse para que pueda ser manejada por un nivel superior en la jerarquía de llamadas.\n\n* **Usa excepciones para situaciones excepcionales**: No uses excepciones para el flujo normal del programa. Las excepciones deben reservarse para errores y condiciones inesperadas.\n\n## SUBTEMAS SUGERIDOS\n\n* **Context Managers (with statement)**: Simplifica el manejo de recursos (como archivos) asegurando que se liberen automáticamente.\n\n* **Logging**: Registra información sobre excepciones para facilitar la depuración y el monitoreo de aplicaciones.\n\n* **Testing**: Escribe pruebas unitarias para verificar que las excepciones se manejen correctamente.\n\nEl manejo de excepciones es una habilidad esencial para cualquier programador de Python. Al comprender cómo funcionan los bloques try, except y finally, y al seguir las buenas prácticas, puedes escribir código más robusto y tolerante a fallos.\n"
  },
  {
    "slug": "/programming/languages/python/functions",
    "title": "Funciones en Python",
    "description": "Explicación detallada de las funciones en Python, incluyendo su sintaxis, tipos, uso y mejores prácticas.",
    "content": "Las funciones son bloques de código reutilizables que realizan una tarea específica. Son fundamentales en la programación porque permiten dividir un programa grande en partes más pequeñas y manejables, lo que facilita la lectura, la depuración y el mantenimiento del código. En Python, las funciones se definen utilizando la palabra clave `def`.\n\n## SINTAXIS BASICA\n\nLa sintaxis básica para definir una función en Python es la siguiente:\n\n```python\ndef nombre_de_la_funcion(parametros):\r\n    \"\"\"\r\n    Documentación de la función (docstring).\r\n    Explica qué hace la función, qué parámetros acepta y qué retorna.\r\n    \"\"\"\r\n    # Cuerpo de la función\r\n    # Aquí va el código que realiza la tarea\r\n    return valor_de_retorno  # Opcional\n```\n\n* **def**: Palabra clave que indica el inicio de la definición de una función.\n\n* **nombre\\_de\\_la\\_funcion**: El nombre que le das a la función. Debe seguir las reglas de nomenclatura de Python (letras, números y guiones bajos, comenzando con una letra o guión bajo).\n\n* **parametros**: Son las variables que la función recibe como entrada. Pueden ser cero o más parámetros, separados por comas.\n\n* **\"\"\"Documentación\"\"\"**: Es una cadena de texto (docstring) que describe la función. Es una buena práctica incluir una descripción clara de lo que hace la función, los parámetros que acepta y el valor que retorna.\n\n* **cuerpo de la función**: Es el bloque de código que se ejecuta cuando se llama la función.\n\n* **return**: Palabra clave que indica el valor que la función retorna. Si no se especifica return, la función retorna None por defecto.\n\n## TIPOS DE FUNCIONES\n\n### 1. FUNCIONES SIN PARAMETROS Y SIN RETORNO\n\n```python\ndef saludar():\r\n    print(\"¡Hola, mundo!\")\r\n\r\nsaludar()  # Llama a la función\n```\n\n### 2. FUNCIONES CON PARAMETROS Y SIN RETORNO\n\n```python\ndef saludar_a(nombre):\r\n    print(f\"¡Hola, {nombre}!\")\r\n\r\nsaludar_a(\"Juan\")  # Llama a la función con un argumento\n```\n\n### 3. FUNCIONES CON PARAMETROS Y CON RETORNO\n\n```python\ndef sumar(a, b):\r\n    \"\"\"\r\n    Retorna la suma de dos números.\r\n    \"\"\"\r\n    return a + b\r\n\r\nresultado = sumar(5, 3)\r\nprint(resultado)  # Imprime 8\n```\n\n### 4. FUNCIONES CON PARAMETROS POR DEFECTO\n\n```python\ndef saludar_con_saludo(nombre, saludo=\"Hola\"):\r\n    print(f\"{saludo}, {nombre}!\")\r\n\r\nsaludar_con_saludo(\"María\")  # Imprime \"Hola, María!\"\r\nsaludar_con_saludo(\"Carlos\", \"Buenos días\")  # Imprime \"Buenos días, Carlos!\"\n```\n\n## ARGUMENTOS DE UNA FUNCION\n\nCuando se llama a una función, se le pueden pasar argumentos. Hay diferentes tipos de argumentos:\n\n### 1. ARGUMENTOS POSICIONALES\n\nLos argumentos se pasan en el mismo orden en que se definen los parámetros en la función.\n\n```python\ndef restar(a, b):\r\n    return a - b\r\n\r\nresultado = restar(10, 3)  # a = 10, b = 3\r\nprint(resultado)  # Imprime 7\n```\n\n### 2. ARGUMENTOS DE PALABRA CLAVE\n\nLos argumentos se pasan especificando el nombre del parámetro y su valor.\n\n```python\ndef restar(a, b):\r\n    return a - b\r\n\r\nresultado = restar(b=3, a=10)  # a = 10, b = 3\r\nprint(resultado)  # Imprime 7\n```\n\n### 3. ARGUMENTOS VARIABLES (\\*args)\n\nPermiten pasar un número variable de argumentos posicionales. Se reciben como una tupla.\n\n```python\ndef sumar_todos(*args):\r\n    total = 0\r\n    for num in args:\r\n        total += num\r\n    return total\r\n\r\nresultado = sumar_todos(1, 2, 3, 4, 5)\r\nprint(resultado)  # Imprime 15\n```\n\n### 4. ARGUMENTOS DE PALABRAS CLAVE VARIABLES (\\*\\*kwargs)\n\nPermiten pasar un número variable de argumentos de palabra clave. Se reciben como un diccionario.\n\n```python\ndef imprimir_info(**kwargs):\r\n    for key, value in kwargs.items():\r\n        print(f\"{key}: {value}\")\r\n\r\nimprimir_info(nombre=\"Juan\", edad=30, ciudad=\"Madrid\")\n```\n\n## ALCANCE DE LAS VARIABLES\n\nEl alcance de una variable se refiere a la parte del programa donde la variable es accesible. En Python, hay dos tipos principales de alcance:\n\n### 1. ALCANCE LOCAL\n\nUna variable definida dentro de una función tiene un alcance local. Solo es accesible dentro de esa función.\n\n```python\ndef mi_funcion():\r\n    x = 10  # x es una variable local\r\n    print(x)\r\n\r\nmi_funcion()  # Imprime 10\r\n# print(x)  # Esto daría un error porque x no está definida fuera de la función\n```\n\n### 2. ALCANCE GLOBAL\n\nUna variable definida fuera de cualquier función tiene un alcance global. Es accesible desde cualquier parte del programa, incluyendo dentro de las funciones.\n\n```python\nx = 10  # x es una variable global\r\n\r\ndef mi_funcion():\r\n    print(x)  # Accede a la variable global x\r\n\r\nmi_funcion()  # Imprime 10\r\nprint(x)  # Imprime 10\n```\n\nSi quieres modificar una variable global dentro de una función, debes usar la palabra clave global\n\n```python\nx = 10\r\n\r\ndef modificar_x():\r\n    global x\r\n    x = 20  # Modifica la variable global x\r\n\r\nmodificar_x()\r\nprint(x)  # Imprime 20\n```\n\n## FUNCIONES ANONIMAS (LAMBDA)\n\nLas funciones lambda son pequeñas funciones anónimas que se definen en una sola línea. Se utilizan principalmente para operaciones simples y cortas.\n\n```python\nsumar = lambda a, b: a + b\r\nresultado = sumar(5, 3)\r\nprint(resultado)  # Imprime 8\n```\n\nLas funciones lambda son especialmente útiles cuando se utilizan con funciones como `map()`, `filter()` y `sorted()`.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\r\ncuadrados = list(map(lambda x: x**2, numeros))\r\nprint(cuadrados)  # Imprime [1, 4, 9, 16, 25]\r\n\r\npares = list(filter(lambda x: x % 2 == 0, numeros))\r\nprint(pares)  # Imprime [2, 4]\n```\n\n## DOCUMENTACION DE FUNCIONES (Docstrings)\n\nEs fundamental documentar las funciones para que otros (o tú mismo en el futuro) puedan entender fácilmente qué hacen. La documentación se incluye como una cadena de texto (docstring) dentro de la función, justo después de la definición.\n\n```python\ndef dividir(a, b):\r\n    \"\"\"\r\n    Divide dos números y retorna el resultado.\r\n\r\n    Args:\r\n        a (int o float): El dividendo.\r\n        b (int o float): El divisor.\r\n\r\n    Returns:\r\n        float: El resultado de la división.\r\n\r\n    Raises:\r\n        ZeroDivisionError: Si el divisor es cero.\r\n    \"\"\"\r\n    if b == 0:\r\n        raise ZeroDivisionError(\"No se puede dividir por cero.\")\r\n    return a / b\n```\n\nPuedes acceder a la documentación de una función utilizando la función `help()` o el atributo `__doc__`.\n\n```python\nhelp(dividir)\r\nprint(dividir.__doc__)\n```\n\n## EJEMPLOS DE FUNCIONES\n\n### 1. FUNCION PARA CALCULAR EL FACTORIAL DE UN NUMERO\n\n```python\ndef factorial(n):\r\n    \"\"\"\r\n    Calcula el factorial de un número entero no negativo.\r\n    \"\"\"\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return n * factorial(n-1)\r\n\r\nprint(factorial(5))  # Imprime 120\n```\n\n2. FUNCION PARA VERIFICAR SI UN NUMERO ES PRIMO\n\n```python\ndef es_primo(n):\r\n    \"\"\"\r\n    Verifica si un número es primo.\r\n    \"\"\"\r\n    if n <= 1:\r\n        return False\r\n    for i in range(2, int(n**0.5) + 1):\r\n        if n % i == 0:\r\n            return False\r\n    return True\r\n\r\nprint(es_primo(7))  # Imprime True\r\nprint(es_primo(10)) # Imprime False\n```\n\n## SUBTEMAS SUGERIDOS\n\n* **Decoradores**: Funciones que modifican el comportamiento de otras funciones.\n\n* **Generadores**: Funciones que producen una secuencia de valores utilizando la palabra clave yield.\n\n* **Recursión**: Funciones que se llaman a sí mismas para resolver un problema.\n\n* **Programación Funcional**: Uso de funciones como ciudadanos de primera clase, funciones puras y funciones de orden superior.\n\nLas funciones son una herramienta poderosa en Python que permite escribir código modular, reutilizable y fácil de mantener. Dominar su uso es esencial para cualquier programador de Python.\n"
  },
  {
    "slug": "/programming/languages/python",
    "title": "Python",
    "description": "Python es un lenguaje de programación de alto nivel, interpretado y de propósito general, conocido por su sintaxis clara y legible.",
    "content": "Python es un lenguaje de programación ampliamente utilizado en diversas áreas, desde el desarrollo web hasta la ciencia de datos y el aprendizaje automático. Su diseño enfatiza la legibilidad del código, utilizando una sintaxis que es fácil de entender y aprender. Esto lo convierte en una excelente opción tanto para principiantes como para desarrolladores experimentados.\n\n### Historia de Python\n\nPython fue creado por Guido van Rossum y lanzado por primera vez en 1991. Van Rossum trabajaba en el Centrum Wiskunde & Informatica (CWI) en los Países Bajos cuando comenzó a desarrollar Python como un sucesor del lenguaje ABC. El nombre \"Python\" proviene de la afición de Van Rossum por el grupo de comedia británico Monty Python.\n\nEl diseño de Python se centró en la legibilidad del código y la facilidad de uso. Van Rossum creía que el código debería ser fácil de entender y mantener, y que los desarrolladores deberían poder escribir programas de manera rápida y eficiente.\n\nA lo largo de los años, Python ha evolucionado y ha ganado una gran comunidad de desarrolladores que contribuyen con bibliotecas y herramientas que amplían sus capacidades. Python 2.0 fue lanzado en 2000, introduciendo nuevas características como la recolección de basura y el soporte Unicode. Python 3.0, una versión importante que no es retrocompatible con Python 2.0, fue lanzado en 2008 y trajo consigo mejoras significativas en el lenguaje.\n\n### Objetivos Clave de Python\n\n1. **Legibilidad del Código:** Python está diseñado para ser fácil de leer y entender. Su sintaxis clara y legible facilita la escritura y el mantenimiento del código.\n2. **Versatilidad:** Python es un lenguaje de propósito general que se puede utilizar en una amplia variedad de aplicaciones, desde el desarrollo web hasta la ciencia de datos y el aprendizaje automático.\n3. **Gran Comunidad y Ecosistema:** Python cuenta con una gran comunidad de desarrolladores que contribuyen con bibliotecas y herramientas que amplían sus capacidades. Esto facilita la búsqueda de soluciones a problemas comunes y la colaboración en proyectos.\n4. **Multiplataforma:** Python es compatible con una amplia variedad de sistemas operativos, incluyendo Windows, macOS y Linux. Esto permite a los desarrolladores escribir código que se puede ejecutar en diferentes plataformas sin necesidad de realizar modificaciones significativas.\n5. **Fácil de Aprender:** Python es un lenguaje fácil de aprender, lo que lo convierte en una excelente opción para principiantes. Su sintaxis clara y legible facilita la comprensión de los conceptos básicos de la programación.\n\n### Instalación de Python\n\nLa instalación de Python es un proceso sencillo que varía ligeramente dependiendo del sistema operativo.\n\n#### En Windows:\n\n1. **Descargar:** Visita el sitio web oficial de Python ([https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)) y descarga la última versión de Python para Windows.\n2. **Ejecutar:** Ejecuta el archivo descargado. Asegúrate de marcar la casilla \"Add Python to PATH\" durante la instalación para que Python sea accesible desde la línea de comandos.\n3. **Verificar:** Abre la línea de comandos y escribe `python --version`. Deberías ver la versión de Python instalada.\n\n#### En macOS:\n\n1. **Descargar:** Visita el sitio web oficial de Python ([https://www.python.org/downloads/macos/](https://www.python.org/downloads/macos/)) y descarga la última versión de Python para macOS.\n2. **Ejecutar:** Ejecuta el archivo descargado y sigue las instrucciones del instalador.\n3. **Verificar:** Abre la terminal y escribe `python3 --version`. Deberías ver la versión de Python instalada.\n\n#### En Linux:\n\nEn la mayoría de las distribuciones de Linux, Python ya está instalado por defecto. Sin embargo, es posible que necesites instalar la última versión.\n\n1. **Actualizar el Gestor de Paquetes:** Abre la terminal y ejecuta el comando `sudo apt update` (para Debian/Ubuntu) o `sudo yum update` (para Fedora/CentOS).\n2. **Instalar Python:** Ejecuta el comando `sudo apt install python3` (para Debian/Ubuntu) o `sudo yum install python3` (para Fedora/CentOS).\n3. **Verificar la Instalación:** Escribe `python3 --version` en la terminal. Deberías ver la versión de Python instalada.\n\n### Información Adicional Interesante\n\n* **Tipado Dinámico:** Python es un lenguaje de tipado dinámico, lo que significa que no es necesario declarar el tipo de una variable antes de usarla. El tipo de una variable se determina en tiempo de ejecución.\n* **Tipado Fuerte:** Python es un lenguaje de tipado fuerte, lo que significa que no se permiten operaciones entre tipos de datos incompatibles. Por ejemplo, no se puede sumar una cadena de texto a un número entero.\n* **Orientado a Objetos:** Python es un lenguaje orientado a objetos, lo que significa que se basa en el concepto de objetos, que son instancias de clases. Los objetos tienen atributos (datos) y métodos (funciones) que operan sobre esos datos.\n* **Interpretado:** Python es un lenguaje interpretado, lo que significa que el código se ejecuta línea por línea por un intérprete, en lugar de ser compilado en código máquina. Esto facilita la depuración y el desarrollo rápido de aplicaciones.\n\n### Ejemplos de Implementación\n\n#### Ejemplo 1: Hola Mundo\n\n```python\nprint(\"Hola, mundo!\")\n```\n\nEste es el programa más simple en Python. La función print() muestra el texto \"Hola, mundo!\" en la consola.\n\n#### Ejemplo 2: Suma de Dos Números\n\n```python\na = 10\r\nb = 20\r\nsuma = a + b\r\nprint(\"La suma de\", a, \"y\", b, \"es\", suma)\n```\n\nEste programa define dos variables, a y b, y calcula su suma. Luego, muestra el resultado en la consola.\n\n#### Ejemplo 3: Bucle For\n\n```python\nfor i in range(5):\r\n    print(\"El valor de i es:\", i)\n```\n\nEste programa utiliza un bucle for para iterar sobre los números del 0 al 4 y muestra el valor de i en cada iteración.\n\n#### Ejemplo 4: Función\n\n```python\ndef saludar(nombre):\r\n    print(\"Hola, \" + nombre + \"!\")\r\n\r\nsaludar(\"Juan\")\n```\n"
  },
  {
    "slug": "/programming/languages/python/libraries",
    "title": "Bibliotecas de programación para Python",
    "description": "Exploración de las bibliotecas esenciales de Python para diversas tareas de programación.",
    "content": "Las bibliotecas de Python son colecciones de módulos y funciones que extienden las capacidades del lenguaje base. Facilitan la realización de tareas complejas sin necesidad de escribir código desde cero. Python, gracias a su vasta comunidad y versatilidad, cuenta con un ecosistema de bibliotecas muy rico y diverso, que abarca desde el desarrollo web hasta la ciencia de datos y el aprendizaje automático.\n\n## OBJETIVOS CLAVE\n\n1. **Facilitar la reutilización de código:** Las bibliotecas permiten a los desarrolladores utilizar código probado y optimizado, ahorrando tiempo y esfuerzo.\n2. **Acelerar el desarrollo:** Al proporcionar herramientas y funciones predefinidas, las bibliotecas agilizan el proceso de desarrollo de software.\n3. **Resolver problemas específicos:** Existen bibliotecas especializadas para abordar problemas en áreas como el análisis de datos, la visualización, el desarrollo web, y más.\n4. **Promover la estandarización:** Las bibliotecas populares establecen estándares de facto para ciertas tareas, lo que facilita la colaboración y el intercambio de código entre desarrolladores.\n\n## BIBLIOTECAS ESENCIALES DE PYTHON\n\n* **NumPy:** Fundamental para la computación numérica. Proporciona soporte para arrays multidimensionales y funciones matemáticas de alto rendimiento. Es la base de muchas otras bibliotecas de ciencia de datos.\n* **Pandas:** Ofrece estructuras de datos y herramientas para el análisis y manipulación de datos tabulares. Facilita la limpieza, transformación y análisis de datos.\n* **Matplotlib:** Biblioteca para la creación de gráficos y visualizaciones de datos. Permite generar una amplia variedad de gráficos, desde histogramas hasta gráficos de dispersión y mapas de calor.\n* **Seaborn:** Construida sobre Matplotlib, proporciona una interfaz de alto nivel para crear gráficos estadísticos atractivos e informativos.\n* **Scikit-learn:** Biblioteca para el aprendizaje automático. Ofrece herramientas para clasificación, regresión, clustering, reducción de dimensionalidad, selección de modelos y preprocesamiento de datos.\n* **TensorFlow y Keras:** Bibliotecas para el aprendizaje profundo. TensorFlow es un framework de bajo nivel, mientras que Keras proporciona una interfaz de alto nivel para construir y entrenar modelos de redes neuronales.\n* **PyTorch:** Otra biblioteca popular para el aprendizaje profundo, conocida por su flexibilidad y facilidad de uso.\n* **Flask y Django:** Frameworks para el desarrollo web. Flask es un microframework ligero, mientras que Django es un framework más completo que ofrece una amplia gama de características.\n* **Requests:** Biblioteca para realizar solicitudes HTTP. Facilita la interacción con APIs web y la obtención de datos de la web.\n* **Beautiful Soup:** Biblioteca para el análisis sintáctico de HTML y XML. Permite extraer información de páginas web de forma sencilla.\n* **SQLAlchemy:** Biblioteca para la interacción con bases de datos relacionales. Proporciona una interfaz de alto nivel para realizar consultas y manipular datos.\n\n## EJEMPLOS DE IMPLEMENTACIÓN\n\n* **Análisis de datos con Pandas:**\n\n```python\nimport pandas as pd\r\n\r\n# Cargar datos desde un archivo CSV\r\ndata = pd.read_csv('data.csv')\r\n\r\n# Mostrar las primeras filas del DataFrame\r\nprint(data.head())\r\n\r\n# Calcular estadísticas descriptivas\r\nprint(data.describe())\n```\n\n### VISUALIZACION DE DATOS CON Matplotlib:\n\n```python\nimport matplotlib.pyplot as plt\r\n\r\n# Crear un gráfico de líneas\r\nplt.plot([1, 2, 3, 4], [5, 6, 7, 8])\r\n\r\n# Añadir etiquetas y título\r\nplt.xlabel('Eje X')\r\nplt.ylabel('Eje Y')\r\nplt.title('Gráfico de líneas')\r\n\r\n# Mostrar el gráfico\r\nplt.show()\n```\n\n### DESARROLLO WEB CON Flask:\n\n```python\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route('/')\r\ndef hello_world():\r\n    return '¡Hola, mundo!'\r\n\r\nif __name__ == '__main__':\r\n    app.run()\n```\n\n## MAS INFORMACION INTERESANTE\n\n* **Gestión de dependencias**: Es importante utilizar un gestor de dependencias como pip o conda para instalar y gestionar las bibliotecas de Python.\n\n* **Entornos virtuales**: Se recomienda utilizar entornos virtuales para aislar las dependencias de cada proyecto y evitar conflictos entre bibliotecas.\n\n* **Documentación**: La documentación oficial de cada biblioteca es la mejor fuente de información para aprender a utilizarla correctamente.\n\n## SUBTEMAS SUGERIDOS\n\n* Bibliotecas para el procesamiento del lenguaje natural (NLTK, SpaCy).\n\n* Bibliotecas para el desarrollo de juegos (Pygame, Pyglet).\n\n* Bibliotecas para la creación de interfaces gráficas de usuario (Tkinter, PyQt).\n\n* Bibliotecas para el desarrollo de aplicaciones móviles (Kivy, BeeWare).\n"
  },
  {
    "slug": "/programming/languages/python/modules-packages",
    "title": "Módulos y Paquetes en Python",
    "description": "Explicación detallada sobre cómo organizar y reutilizar código en Python mediante módulos y paquetes.",
    "content": "Los módulos y paquetes son mecanismos fundamentales en Python para organizar y reutilizar código. Permiten estructurar proyectos grandes en componentes más manejables, facilitando el mantenimiento, la legibilidad y la colaboración.\n\n## ¿QUE ES UN MODULO EN PYTHON?\n\nUn módulo en Python es simplemente un archivo que contiene código Python, como definiciones de funciones, clases o variables. El nombre del archivo es el nombre del módulo con la extensión `.py`. Los módulos permiten dividir un programa grande en archivos más pequeños y manejables.\n\n### OBJETIVOS CLAVE DE LOS MODULOS\n\n* **Reutilización de código:** Permiten usar funciones y clases definidas en un archivo en otros archivos.\n* **Organización:** Facilitan la estructuración de proyectos grandes en componentes lógicos.\n* **Namespace:** Crean espacios de nombres separados, evitando conflictos entre nombres de variables y funciones.\n\n### ¿COMO IMPORTAR UN MODULO?\n\nPara utilizar un módulo en Python, se utiliza la declaración `import`. Existen varias formas de importar módulos:\n\n#### 1. IMPORTAR EL MODULO COMPLETO\n\n```python\nimport nombre_del_modulo\n```\n\nEsto importa el módulo completo y se accede a sus elementos utilizando la notación de punto: `nombre_del_modulo.elemento`.\n\nEjemplo:\n\n```python\nimport math\r\nprint(math.sqrt(16))  # Output: 4.0\n```\n\n#### 2. IMPORTAR ELEMENTOS ESPECIFICOS DEL MODULO\n\n```python\nfrom nombre_del_modulo import elemento1, elemento2, ...\n```\n\nEsto importa solo los elementos especificados del módulo, y se pueden utilizar directamente sin la notación de punto.\n\nEjemplo:\n\n```python\nfrom math import sqrt, pi\r\nprint(sqrt(16))  # Output: 4.0\r\nprint(pi)       # Output: 3.141592653589793\n```\n\n#### 3. IMPORTAR TODOS LOS ELEMENTOS DEL MODULO (NO RECOMENDADO)\n\n```python\nfrom nombre_del_modulo import *\n```\n\nEsto importa todos los elementos del módulo al espacio de nombres actual. No se recomienda porque puede llevar a conflictos de nombres y dificulta la legibilidad del código.\n\n#### 4. ASIGNAR UN ALIAS AL MODULO O A SUS ELEMENTOS\n\n```python\nimport nombre_del_modulo as alias\r\nfrom nombre_del_modulo import elemento as otro_alias\n```\n\nEsto permite utilizar un nombre diferente para referirse al módulo o a sus elementos.\n\nEjemplo:\n\n```python\nimport math as m\r\nprint(m.sqrt(25))  # Output: 5.0\r\n\r\nfrom datetime import datetime as dt\r\nnow = dt.now()\r\nprint(now)\n```\n\n## ¿QUE ES UN PAQUETE EN PYTHON?\n\nUn paquete en Python es una forma de organizar módulos relacionados en un directorio. Un directorio se considera un paquete si contiene un archivo especial llamado `__init__.py`. Este archivo puede estar vacío o contener código de inicialización para el paquete.\n\n### OBJETIVOS CLAVE DE LOS PAQUETES\n\n* **Jerarquía:** Permiten crear una jerarquía de módulos, organizando el código en subpaquetes y submódulos.\n* **Organización a gran escala:** Facilitan la gestión de proyectos grandes y complejos.\n* **Namespace:** Proporcionan un espacio de nombres jerárquico, evitando conflictos entre nombres de módulos.\n\n### ESTRUCTURA DE UN PAQUETE\n\nLa estructura típica de un paquete es la siguiente\n\n<FileTree>\n  <Folder name=\"mi_paquete\" label=\"Mi Paquete\">\n    <File name=\"init.py\" label=\"Init File\" />\n\n    <File name=\"modulo1.py\" label=\"Módulo 1 File\" />\n\n    <File name=\"modulo2.py\" label=\"Módulo 2 File\" />\n\n    <Folder name=\"subpaquete\" label=\"Subpaquete\">\n      <File name=\"init.py\" label=\"Init File\" />\n\n      <File name=\"submodulo1.py\" label=\"Submódulo 1 File\" />\n\n      <File name=\"submodulo2.py\" label=\"Submódulo 2 File\" />\n    </Folder>\n  </Folder>\n</FileTree>\n\n* `mi_paquete`: Es el directorio raíz del paquete.\n* `__init__.py`: Es el archivo que indica que el directorio es un paquete.\n* `modulo1.py`, `modulo2.py`: Son módulos dentro del paquete.\n* `subpaquete`: Es un subpaquete dentro del paquete principal.\n* `submodulo1.py`, `submodulo2.py`: Son módulos dentro del subpaquete.\n\n### ¿COMO IMPORTAR DESDE UN PAQUETE?\n\nExisten varias formas de importar módulos y elementos desde un paquete:\n\n#### 1.  IMPORTAR EL PAQUETE COMPLETO\n\n```python\nimport mi_paquete\n```\n\nEsto importa el paquete, pero no sus módulos directamente. Para acceder a los módulos, se utiliza la notación de punto: `mi_paquete.modulo1`.\n\n#### 2.  IMPORTAR UN MODULO ESPECIFICO DEL PAQUETE\n\n```python\nimport mi_paquete.modulo1\n```\n\nEsto importa el módulo `modulo1` del paquete `mi_paquete`. Se accede a sus elementos utilizando la notación de punto: `mi_paquete.modulo1.funcion`.\n\n#### 3.  IMPORTAR ELEMENTOS ESPECIFICOS DE UN MODULO DENTRO DEL PAQUETE\n\n```python\nfrom mi_paquete.modulo1 import funcion1, funcion2\n```\n\nEsto importa las funciones `funcion1` y `funcion2` del módulo `modulo1` dentro del paquete `mi_paquete`. Se pueden utilizar directamente sin la notación de punto.\n\n#### 4.  IMPORTAR UN SUBPAQUETE\n\n```python\nimport mi_paquete.subpaquete\n```\n\nEsto importa el subpaquete `subpaquete` del paquete `mi_paquete`.\n\n#### 5.  IMPORTAR UN MODULO DESDE UN SUBPAQUETE\n\n```python\nfrom mi_paquete.subpaquete import submodulo1\n```\n\nEsto importa el módulo `submodulo1` del subpaquete `subpaquete` dentro del paquete `mi_paquete`.\n\n### EL ARCHIVO **init**.py\n\nEl archivo `__init__.py` es un archivo especial que se ejecuta cuando se importa un paquete. Puede contener código para inicializar el paquete, como la importación de módulos y la definición de variables.\n\n#### USOS COMUNES DE **init**.py\n\n* **Inicialización del paquete:** Puede contener código para configurar el entorno del paquete.\n* **Importación de submódulos:** Puede importar submódulos para que estén disponibles directamente desde el paquete.\n* **Definición de la API del paquete:** Puede definir qué módulos y funciones son parte de la API pública del paquete.\n\n#### EJEMPLO\n\n```python\n# mi_paquete/__init__.py\r\nfrom .modulo1 import funcion1\r\nfrom .modulo2 import funcion2\r\n\r\n__all__ = ['funcion1', 'funcion2']\n```\n\nEn este ejemplo, `__init__.py` importa `funcion1` de `modulo1.py` y `funcion2` de `modulo2.py`, y los hace disponibles directamente desde el paquete `mi_paquete`. La variable `__all__` define la lista de nombres que se importan cuando se utiliza `from mi_paquete import *`.\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### EJEMPLO DE MODULO\n\nSupongamos que tenemos un archivo llamado `calculadora.py` con el siguiente contenido\n\n```python\n# calculadora.py\r\n\r\ndef sumar(a, b):\r\n    \"\"\"Suma dos números.\"\"\"\r\n    return a + b\r\n\r\ndef restar(a, b):\r\n    \"\"\"Resta dos números.\"\"\"\r\n    return a - b\n```\n\nPara usar este módulo en otro archivo\n\n```python\n# main.py\r\nimport calculadora\r\n\r\nresultado_suma = calculadora.sumar(5, 3)\r\nresultado_resta = calculadora.restar(10, 4)\r\n\r\nprint(f\"Suma: {resultado_suma}\")   # Output: Suma: 8\r\nprint(f\"Resta: {resultado_resta}\")  # Output: Resta: 6\n```\n\n### EJEMPLO DE PAQUETE\n\nConsideremos la siguiente estructura de paquete\n\n<FileTree>\n  <Folder name=\"mi_paquete\" label=\"Mi paquete\">\n    <File name=\"__init__.py\" label=\"Init File\" />\n\n    <Folder name=\"operaciones\" label=\"Operaciones\">\n      <File name=\"__init__.py\" label=\"Init File\" />\n\n      <File name=\"aritmetica.py\" label=\"Aritmética File\" />\n\n      <File name=\"trigonometria.py\" label=\"Trigonometría File\" />\n    </Folder>\n  </Folder>\n</FileTree>\n\n`mi_paquete/__init__.py`\n\n```python\n# mi_paquete/__init__.py\r\nprint(\"Inicializando mi_paquete\")\n```\n\n`mi_paquete/operaciones/__init__.py`\n\n```python\n# mi_paquete/operaciones/__init__.py\r\nprint(\"Inicializando el subpaquete operaciones\")\n```\n\n`mi_paquete/operaciones/aritmetica.py`\n\n```python\n# mi_paquete/operaciones/aritmetica.py\r\ndef multiplicar(a, b):\r\n    \"\"\"Multiplica dos números.\"\"\"\r\n    return a * b\r\n\r\ndef dividir(a, b):\r\n    \"\"\"Divide dos números.\"\"\"\r\n    if b == 0:\r\n        return \"Error: No se puede dividir por cero.\"\r\n    return a / b\n```\n\n`mi_paquete/operaciones/trigonometria.py`\n\n```python\n# mi_paquete/operaciones/trigonometria.py\r\nimport math\r\n\r\ndef seno(angulo):\r\n    \"\"\"Calcula el seno de un ángulo en radianes.\"\"\"\r\n    return math.sin(angulo)\r\n\r\ndef coseno(angulo):\r\n    \"\"\"Calcula el coseno de un ángulo en radianes.\"\"\"\r\n    return math.cos(angulo)\n```\n\nPara usar este paquete\n\n```python\n# main.py\r\nfrom mi_paquete.operaciones import aritmetica, trigonometria\r\n\r\nresultado_multiplicacion = aritmetica.multiplicar(4, 6)\r\nresultado_seno = trigonometria.seno(math.pi / 2)\r\n\r\nprint(f\"Multiplicación: {resultado_multiplicacion}\")  # Output: Multiplicación: 24\r\nprint(f\"Seno: {resultado_seno}\")                    # Output: Seno: 1.0\n```\n\n## SUBTEMAS SUGERIDOS\n\n* **Namespaces en Python**: Profundizar en cómo Python gestiona los espacios de nombres y cómo los módulos y paquetes influyen en ellos.\n\n* ****all** variable**: Explicar en detalle cómo se utiliza la variable **all** para controlar qué nombres se exportan de un módulo o paquete.\n\n* **Importación relativa vs. absoluta**: Diferencias y usos de las importaciones relativas (ej. from . import modulo) y absolutas (ej. from mi\\_paquete import modulo).\n\n* **Manejo de errores en la importación**: Cómo manejar excepciones que pueden ocurrir durante la importación de módulos y paquetes.\n\n* **Creación de paquetes distribuibles**: Cómo crear paquetes que se pueden instalar y distribuir utilizando herramientas como pip.\n"
  },
  {
    "slug": "/programming/languages/python/oop",
    "title": "Programación Orientada a Objetos en Python",
    "description": "Explicación detallada de los conceptos de la programación orientada a objetos (POO) en Python, incluyendo clases, objetos, herencia, polimorfismo, encapsulamiento y abstracción.",
    "content": "La Programación Orientada a Objetos (POO) es un paradigma de programación que utiliza \"objetos\" para diseñar aplicaciones y programas de computadora. Un objeto combina datos (atributos) y código (métodos) que operan sobre esos datos. La POO se basa en varios principios clave que facilitan la creación de software modular, reutilizable y fácil de mantener. Python es un lenguaje que soporta completamente la POO, permitiendo a los desarrolladores aprovechar sus beneficios.\n\n## CONCEPTOS CLAVE DE LA POO\n\n### 1.  CLASE\n\n* Una clase es una plantilla o un plano para crear objetos. Define los atributos (datos) y los métodos (comportamiento) que tendrán los objetos de esa clase.\n* En Python, las clases se definen utilizando la palabra clave `class`.\n\n```python\nclass Perro:\r\n    # Atributos de la clase\r\n    especie = \"Canino\"\r\n\r\n    # Método constructor\r\n    def __init__(self, nombre, edad):\r\n        self.nombre = nombre\r\n        self.edad = edad\r\n\r\n    # Métodos de la clase\r\n    def ladrar(self):\r\n        return \"¡Guau!\"\r\n\r\n    def descripcion(self):\r\n        return f\"{self.nombre} tiene {self.edad} años.\"\n```\n\n### 2.  OBJETO\n\n* Un objeto es una instancia de una clase. Es una entidad concreta que tiene atributos con valores específicos y puede realizar acciones definidas por los métodos de su clase.\n* Para crear un objeto, se llama al constructor de la clase.\n\n```python\n# Crear objetos de la clase Perro\r\nmi_perro = Perro(\"Buddy\", 3)\r\notro_perro = Perro(\"Max\", 5)\r\n\r\n# Acceder a los atributos del objeto\r\nprint(mi_perro.nombre)  # Imprime \"Buddy\"\r\nprint(otro_perro.edad)  # Imprime 5\r\n\r\n# Llamar a los métodos del objeto\r\nprint(mi_perro.ladrar())  # Imprime \"¡Guau!\"\r\nprint(otro_perro.descripcion())  # Imprime \"Max tiene 5 años.\"\n```\n\n### 3.  ATRIBUTOS\n\n* Los atributos son las características o propiedades de un objeto. Representan los datos que el objeto contiene.\n* En Python, los atributos se definen dentro de la clase y se acceden utilizando la notación de punto (`objeto.atributo`).\n* Hay atributos de clase (compartidos por todas las instancias) y atributos de instancia (únicos para cada objeto).\n\n```python\nclass Perro:\r\n    # Atributo de clase\r\n    especie = \"Canino\"\r\n\r\n    def __init__(self, nombre, edad):\r\n        # Atributos de instancia\r\n        self.nombre = nombre\r\n        self.edad = edad\n```\n\n### 4.  METODOS\n\n* Los métodos son las acciones o funciones que un objeto puede realizar. Definen el comportamiento del objeto.\n* En Python, los métodos se definen dentro de la clase y siempre tienen al menos un parámetro, que es `self` (una referencia al objeto mismo).\n\n```python\nclass Perro:\r\n    def __init__(self, nombre, edad):\r\n        self.nombre = nombre\r\n        self.edad = edad\r\n\r\n    def ladrar(self):\r\n        return \"¡Guau!\"\n```\n\n### 5.  HERENCIA\n\n* La herencia es un mecanismo que permite crear nuevas clases (clases hijas o subclases) basadas en clases existentes (clases padre o superclases). La subclase hereda los atributos y métodos de la superclase, y puede añadir nuevos atributos y métodos o modificar los existentes.\n* La herencia promueve la reutilización del código y facilita la creación de jerarquías de clases.\n\n```python\nclass Animal:\r\n    def __init__(self, nombre):\r\n        self.nombre = nombre\r\n\r\n    def hablar(self):\r\n        return \"Sonido genérico de animal\"\r\n\r\nclass Perro(Animal):\r\n    def __init__(self, nombre, raza):\r\n        super().__init__(nombre)  # Llama al constructor de la superclase\r\n        self.raza = raza\r\n\r\n    def hablar(self):\r\n        return \"¡Guau!\"  # Sobreescribe el método de la superclase\r\n\r\nmi_perro = Perro(\"Buddy\", \"Labrador\")\r\nprint(mi_perro.nombre)  # Imprime \"Buddy\"\r\nprint(mi_perro.raza)  # Imprime \"Labrador\"\r\nprint(mi_perro.hablar())  # Imprime \"¡Guau!\"\r\n\r\nmi_animal = Animal(\"Genérico\")\r\nprint(mi_animal.hablar()) # Imprime \"Sonido genérico de animal\"\n```\n\n### 6.  POLIMORFISMO\n\n* El polimorfismo es la capacidad de un objeto de tomar muchas formas. Permite que objetos de diferentes clases respondan al mismo método de manera diferente.\n* En Python, el polimorfismo se implementa a través de la herencia y la sobreescritura de métodos.\n\n```python\nclass Animal:\r\n    def hablar(self):\r\n        return \"Sonido genérico de animal\"\r\n\r\nclass Perro(Animal):\r\n    def hablar(self):\r\n        return \"¡Guau!\"\r\n\r\nclass Gato(Animal):\r\n    def hablar(self):\r\n        return \"¡Miau!\"\r\n\r\ndef hacer_hablar(animal):\r\n    print(animal.hablar())\r\n\r\nmi_perro = Perro()\r\nmi_gato = Gato()\r\n\r\nhacer_hablar(mi_perro)  # Imprime \"¡Guau!\"\r\nhacer_hablar(mi_gato)  # Imprime \"¡Miau!\"\n```\n\n### 7.  ENCAPSULAMIENTO\n\n* El encapsulamiento es el principio de ocultar los detalles internos de un objeto y exponer solo una interfaz pública para interactuar con él. Protege los datos del objeto de accesos no autorizados y facilita el mantenimiento del código.\n* En Python, el encapsulamiento se implementa utilizando convenciones de nomenclatura (atributos y métodos precedidos por uno o dos guiones bajos).\n\n```python\nclass Coche:\r\n    def __init__(self, marca, modelo):\r\n        self.marca = marca\r\n        self.modelo = modelo\r\n        self.__velocidad = 0  # Atributo privado\r\n\r\n    def acelerar(self, incremento):\r\n        if incremento > 0:\r\n            self.__velocidad += incremento\r\n\r\n    def obtener_velocidad(self):\r\n        return self.__velocidad\r\n\r\nmi_coche = Coche(\"Toyota\", \"Corolla\")\r\nmi_coche.acelerar(30)\r\nprint(mi_coche.obtener_velocidad())  # Imprime 30\r\n# print(mi_coche.__velocidad)  # Esto daría un error (AttributeError)\n```\n\n### 8.  ABSTRACCION\n\n* La abstracción es el proceso de simplificar la representación de un objeto, mostrando solo los detalles esenciales y ocultando la complejidad innecesaria. Permite a los desarrolladores concentrarse en lo que hace un objeto en lugar de cómo lo hace.\n* En Python, la abstracción se puede lograr mediante clases abstractas y métodos abstractos.\n\n```python\nfrom abc import ABC, abstractmethod\r\n\r\nclass Figura(ABC):\r\n    @abstractmethod\r\n    def area(self):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def perimetro(self):\r\n        pass\r\n\r\nclass Rectangulo(Figura):\r\n    def __init__(self, base, altura):\r\n        self.base = base\r\n        self.altura = altura\r\n\r\n    def area(self):\r\n        return self.base * self.altura\r\n\r\n    def perimetro(self):\r\n        return 2 * (self.base + self.altura)\r\n\r\n# mi_figura = Figura()  # Esto daría un error (TypeError)\r\nmi_rectangulo = Rectangulo(5, 3)\r\nprint(mi_rectangulo.area())  # Imprime 15\r\nprint(mi_rectangulo.perimetro())  # Imprime 16\n```\n\n## BENEFICIOS DE LA POO\n\n* **Modularidad:** La POO permite dividir un programa en módulos (clases y objetos) independientes, lo que facilita la comprensión y el mantenimiento del código.\n* **Reutilización:** La herencia permite reutilizar el código existente, evitando la duplicación y reduciendo el tiempo de desarrollo.\n* **Extensibilidad:** La POO facilita la adición de nuevas funcionalidades al programa sin modificar el código existente.\n* **Mantenibilidad:** La encapsulación y la abstracción hacen que el código sea más fácil de mantener y modificar, ya que los cambios en una parte del programa no afectan a otras partes.\n\n## EJEMPLOS DE IMPLEMENTACION\n\n### 1.  SISTEMA DE GESTION DE EMPLEADOS\n\n```python\nclass Empleado:\r\n    def __init__(self, nombre, salario):\r\n        self.nombre = nombre\r\n        self.salario = salario\r\n\r\n    def aumentar_salario(self, porcentaje):\r\n        self.salario *= (1 + porcentaje / 100)\r\n\r\n    def __str__(self):\r\n        return f\"Nombre: {self.nombre}, Salario: {self.salario}\"\r\n\r\nclass Gerente(Empleado):\r\n    def __init__(self, nombre, salario, departamento):\r\n        super().__init__(nombre, salario)\r\n        self.departamento = departamento\r\n\r\n    def __str__(self):\r\n        return f\"{super().__str__()}, Departamento: {self.departamento}\"\r\n\r\nempleado1 = Empleado(\"Juan Pérez\", 50000)\r\ngerente1 = Gerente(\"Ana Gómez\", 80000, \"Ventas\")\r\n\r\nprint(empleado1)\r\nprint(gerente1)\r\n\r\nempleado1.aumentar_salario(10)\r\ngerente1.aumentar_salario(15)\r\n\r\nprint(empleado1)\r\nprint(gerente1)\n```\n\n### 2.  SISTEMA DE GESTION DE FIGURAS GEOMETRICAS\n\n```python\nimport math\r\nfrom abc import ABC, abstractmethod\r\n\r\nclass Figura(ABC):\r\n    @abstractmethod\r\n    def area(self):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def perimetro(self):\r\n        pass\r\n\r\nclass Circulo(Figura):\r\n    def __init__(self, radio):\r\n        self.radio = radio\r\n\r\n    def area(self):\r\n        return math.pi * self.radio ** 2\r\n\r\n    def perimetro(self):\r\n        return 2 * math.pi * self.radio\r\n\r\nclass Rectangulo(Figura):\r\n    def __init__(self, base, altura):\r\n        self.base = base\r\n        self.altura = altura\r\n\r\n    def area(self):\r\n        return self.base * self.altura\r\n\r\n    def perimetro(self):\r\n        return 2 * (self.base + self.altura)\r\n\r\nmi_circulo = Circulo(5)\r\nmi_rectangulo = Rectangulo(4, 6)\r\n\r\nprint(f\"Área del círculo: {mi_circulo.area()}\")\r\nprint(f\"Perímetro del círculo: {mi_circulo.perimetro()}\")\r\nprint(f\"Área del rectángulo: {mi_rectangulo.area()}\")\r\nprint(f\"Perímetro del rectángulo: {mi_rectangulo.perimetro()}\")\n```\n\n## SUBSISTEMAS SUGERIDOS\n\n1. **Diseño de Clases:** Principios para diseñar clases efectivas y bien estructuradas.\n2. **Patrones de Diseño:** Soluciones reutilizables para problemas comunes de diseño en la POO.\n3. **Metaclases:** Clases que crean clases, permitiendo un control avanzado sobre la creación de clases.\n4. **Herencia Múltiple:** Herencia de múltiples superclases, con sus ventajas y desventajas.\n5. **Duck Typing:** Un concepto en Python donde la validez de un objeto se determina por la presencia de ciertos métodos y atributos, en lugar de su tipo específico.\n\nLa Programación Orientada a Objetos es una herramienta poderosa para desarrollar software complejo y mantenible. Dominar los conceptos de clases, objetos, herencia, polimorfismo, encapsulamiento y abstracción es fundamental para cualquier programador de Python.\n"
  },
  {
    "slug": "/programming/languages/rikmed",
    "title": "Lenguajes de programación",
    "description": "Esta sección proporciona una descripción general de cómo comenzar a utilizar Documents, Kit de inicio de documentos de Next.js.",
    "content": ""
  },
  {
    "slug": "/programming/languages/typescript",
    "title": "Lenguajes de programación",
    "description": "Esta sección proporciona una descripción general de cómo comenzar a utilizar Documents, Kit de inicio de documentos de Next.js.",
    "content": ""
  },
  {
    "slug": "/programming/web/css",
    "title": "CSS",
    "description": "desc",
    "content": ""
  },
  {
    "slug": "/programming/web/html",
    "title": "HTML",
    "description": "desc",
    "content": ""
  },
  {
    "slug": "/programming/web",
    "title": "Herramientas de desarrollo Web",
    "description": "desc",
    "content": ""
  }
]